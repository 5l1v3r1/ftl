<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>FTL: Functional</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FTL
   </div>
   <div id="projectbrief">The Functional Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functional</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of higher order utility functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classftl_1_1function.html">ftl::function&lt; typename, &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object encapsulator.  <a href="classftl_1_1function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monoid_3_01function_3_01M_00_01Ps_8_8_8_4_01_4.html">ftl::monoid&lt; function&lt; M, Ps...&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monoid instance for ftl::functions returning monoids.  <a href="structftl_1_1monoid_3_01function_3_01M_00_01Ps_8_8_8_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1applicative_3_01function_01_4.html">ftl::applicative&lt; function &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applicative Functor instance for ftl::functions.  <a href="structftl_1_1applicative_3_01function_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae598a3c61d7dc1ff1457deb78d74dd16"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gae598a3c61d7dc1ff1457deb78d74dd16"><td class="memTemplItemLeft" align="right" valign="top">function&lt; function&lt; R, T2 &gt;, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#gae598a3c61d7dc1ff1457deb78d74dd16">ftl::curry</a> (function&lt; R, T1, T2 &gt; f)</td></tr>
<tr class="memdesc:gae598a3c61d7dc1ff1457deb78d74dd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curries a binary function.  <a href="#gae598a3c61d7dc1ff1457deb78d74dd16">More...</a><br/></td></tr>
<tr class="separator:gae598a3c61d7dc1ff1457deb78d74dd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f1358db20380dfc4126767d02c6e0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga64f1358db20380dfc4126767d02c6e0e"></a>
template&lt;typename R , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga64f1358db20380dfc4126767d02c6e0e"><td class="memTemplItemLeft" align="right" valign="top">function&lt; function&lt; R, T2 &gt;, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#ga64f1358db20380dfc4126767d02c6e0e">ftl::curry</a> (R(*f)(T1, T2))</td></tr>
<tr class="memdesc:ga64f1358db20380dfc4126767d02c6e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga64f1358db20380dfc4126767d02c6e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f77d3cf10f787eb397e71c7f4728b6d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ga8f77d3cf10f787eb397e71c7f4728b6d"><td class="memTemplItemLeft" align="right" valign="top">function&lt; function&lt; function<br class="typebreak"/>
&lt; R, T3 &gt;, T2 &gt;, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#ga8f77d3cf10f787eb397e71c7f4728b6d">ftl::curry</a> (function&lt; R, T1, T2, T3 &gt; f)</td></tr>
<tr class="memdesc:ga8f77d3cf10f787eb397e71c7f4728b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curry a ternary function.  <a href="#ga8f77d3cf10f787eb397e71c7f4728b6d">More...</a><br/></td></tr>
<tr class="separator:ga8f77d3cf10f787eb397e71c7f4728b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04e4800c8bebd7f59f3590825dfd103"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac04e4800c8bebd7f59f3590825dfd103"></a>
template&lt;typename R , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:gac04e4800c8bebd7f59f3590825dfd103"><td class="memTemplItemLeft" align="right" valign="top">function&lt; function&lt; function<br class="typebreak"/>
&lt; R, T3 &gt;, T2 &gt;, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#gac04e4800c8bebd7f59f3590825dfd103">ftl::curry</a> (R(*f)(T1, T2, T3))</td></tr>
<tr class="memdesc:gac04e4800c8bebd7f59f3590825dfd103"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gac04e4800c8bebd7f59f3590825dfd103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac91fd71390af9ff105e02e9ff30e87e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac91fd71390af9ff105e02e9ff30e87e1"></a>
template&lt;typename R , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gac91fd71390af9ff105e02e9ff30e87e1"><td class="memTemplItemLeft" align="right" valign="top">function&lt; R, T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#gac91fd71390af9ff105e02e9ff30e87e1">ftl::uncurry</a> (function&lt; function&lt; R, T2 &gt;, T1 &gt; f)</td></tr>
<tr class="memdesc:gac91fd71390af9ff105e02e9ff30e87e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncurries a binary function. <br/></td></tr>
<tr class="separator:gac91fd71390af9ff105e02e9ff30e87e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531e16797e150f533f60b497acfc5e62"><td class="memTemplParams" colspan="2">template&lt;typename F , typename A , typename B  = typename std::result_of&lt;F(A)&gt;::type, typename... Ps&gt; </td></tr>
<tr class="memitem:ga531e16797e150f533f60b497acfc5e62"><td class="memTemplItemLeft" align="right" valign="top">function&lt; B, Ps...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#ga531e16797e150f533f60b497acfc5e62">ftl::compose</a> (F f, A(*fn)(Ps...))</td></tr>
<tr class="memdesc:ga531e16797e150f533f60b497acfc5e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function composition first base case.  <a href="#ga531e16797e150f533f60b497acfc5e62">More...</a><br/></td></tr>
<tr class="separator:ga531e16797e150f533f60b497acfc5e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081d406a1c64e73d9a86e30fb94349b9"><td class="memTemplParams" colspan="2">template&lt;typename F , typename A , typename B  = typename std::result_of&lt;F(A)&gt;::type, typename... Ps&gt; </td></tr>
<tr class="memitem:ga081d406a1c64e73d9a86e30fb94349b9"><td class="memTemplItemLeft" align="right" valign="top">function&lt; B, Ps...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#ga081d406a1c64e73d9a86e30fb94349b9">ftl::compose</a> (F f, function&lt; A, Ps...&gt; fn)</td></tr>
<tr class="memdesc:ga081d406a1c64e73d9a86e30fb94349b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function composition second base case.  <a href="#ga081d406a1c64e73d9a86e30fb94349b9">More...</a><br/></td></tr>
<tr class="separator:ga081d406a1c64e73d9a86e30fb94349b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea8b0bbc9f6e61f389522ad9d61f758"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Fs&gt; </td></tr>
<tr class="memitem:ga4ea8b0bbc9f6e61f389522ad9d61f758"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#ga4ea8b0bbc9f6e61f389522ad9d61f758">ftl::compose</a> (F f, Fs...fs) -&gt; decltype(compose(f, compose(std::forward&lt; Fs &gt;(fs)...)))</td></tr>
<tr class="memdesc:ga4ea8b0bbc9f6e61f389522ad9d61f758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalised, n-ary function composition.  <a href="#ga4ea8b0bbc9f6e61f389522ad9d61f758">More...</a><br/></td></tr>
<tr class="separator:ga4ea8b0bbc9f6e61f389522ad9d61f758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b41de5220eeda386e6be837385b5196"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3b41de5220eeda386e6be837385b5196"></a>
template&lt;typename A , typename B , typename R &gt; </td></tr>
<tr class="memitem:ga3b41de5220eeda386e6be837385b5196"><td class="memTemplItemLeft" align="right" valign="top">function&lt; R, B, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#ga3b41de5220eeda386e6be837385b5196">ftl::flip</a> (function&lt; R, A, B &gt; f)</td></tr>
<tr class="memdesc:ga3b41de5220eeda386e6be837385b5196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the parameter order of a binary function. <br/></td></tr>
<tr class="separator:ga3b41de5220eeda386e6be837385b5196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d56afd16f27e66fdf3b180040405c0f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9d56afd16f27e66fdf3b180040405c0f"></a>
template&lt;typename A , typename B , typename R &gt; </td></tr>
<tr class="memitem:ga9d56afd16f27e66fdf3b180040405c0f"><td class="memTemplItemLeft" align="right" valign="top">function&lt; R, B, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#ga9d56afd16f27e66fdf3b180040405c0f">ftl::flip</a> (R(&amp;f)(A, B))</td></tr>
<tr class="memdesc:ga9d56afd16f27e66fdf3b180040405c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga9d56afd16f27e66fdf3b180040405c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga262e76958ae85c42f0bdd2631deadeb5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga262e76958ae85c42f0bdd2631deadeb5"></a>
template&lt;typename R , typename A , typename B &gt; </td></tr>
<tr class="memitem:ga262e76958ae85c42f0bdd2631deadeb5"><td class="memTemplItemLeft" align="right" valign="top">function&lt; function&lt; R, A &gt;, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__functional.html#ga262e76958ae85c42f0bdd2631deadeb5">ftl::flip</a> (function&lt; function&lt; R, B &gt;, A &gt; f)</td></tr>
<tr class="memdesc:ga262e76958ae85c42f0bdd2631deadeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip parameter order of a curried binary function. <br/></td></tr>
<tr class="separator:ga262e76958ae85c42f0bdd2631deadeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A collection of higher order utility functions. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ftl/functional.h&gt;</span></div>
</div><!-- fragment --><p>The functions herein deal mostly with modifying functions, such as composing them, flipping the order of their parameters, and so on.</p>
<dl class="section user"><dt>Dependencies</dt><dd><ul>
<li><a class="el" href="group__applicative.html">Applicative Functor</a> </li>
</ul>
</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae598a3c61d7dc1ff1457deb78d74dd16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function&lt;function&lt;R,T2&gt;,T1&gt; ftl::curry </td>
          <td>(</td>
          <td class="paramtype">function&lt; R, T1, T2 &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curries a binary function. </p>
<p>Currying is the process of turning a function of (a,b) -&gt; c into a -&gt; b -&gt; c. In other words, instead of taking two arguments and returning the answer, the curried function takes one argument and returns a function that takes another one and <em>then</em> returns the answer.</p>
<dl class="section note"><dt>Note</dt><dd>This requires the "outer" function (the one who takes a parameter and returns an inner function) to capture its parameter by value. In other words, T1 must be copy or move constructible and must not refer to something that will be destroyed or otherwise made inaccessible. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f77d3cf10f787eb397e71c7f4728b6d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T1 , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function&lt;function&lt;function&lt;R,T3&gt;,T2&gt;,T1&gt; ftl::curry </td>
          <td>(</td>
          <td class="paramtype">function&lt; R, T1, T2, T3 &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curry a ternary function. </p>
<p>Similar to the binary curry, except this works with functions taking three parameters. </p>

</div>
</div>
<a class="anchor" id="ga531e16797e150f533f60b497acfc5e62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename A , typename B  = typename std::result_of&lt;F(A)&gt;::type, typename... Ps&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function&lt;B,Ps...&gt; ftl::compose </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A(*)(Ps...)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function composition first base case. </p>
<p>Composes an arbitrary function object with a function pointer. </p>

</div>
</div>
<a class="anchor" id="ga081d406a1c64e73d9a86e30fb94349b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename A , typename B  = typename std::result_of&lt;F(A)&gt;::type, typename... Ps&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function&lt;B,Ps...&gt; ftl::compose </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; A, Ps...&gt;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function composition second base case. </p>
<p>Composes an arbitrary function object with an <a class="el" href="classftl_1_1function.html" title="Function object encapsulator.">ftl::function</a>. </p>

</div>
</div>
<a class="anchor" id="ga4ea8b0bbc9f6e61f389522ad9d61f758"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::compose </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs...&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(compose(f,compose(std::forward&lt;Fs&gt;(fs)...))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalised, n-ary function composition. </p>
<p>Composes an arbitrary number of functions, where each function's return value is piped to the next. The right-most function in the sequence is the first to be evaluated and its result is passed to the one step to the left. Return values must match parameter type of the next one in the chain. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 14 2013 19:01:39 for FTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

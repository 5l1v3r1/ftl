<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>FTL: ftl::monad&lt; M &gt; Interface Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FTL
   </div>
   <div id="projectbrief">The Functional Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ftl</b></li><li class="navelem"><a class="el" href="structftl_1_1monad.html">monad</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="interfaceftl_1_1monad-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ftl::monad&lt; M &gt; Interface Template Reference<div class="ingroups"><a class="el" href="group__monad.html">Monad</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Concrete definition of the monad concept.  
 <a href="structftl_1_1monad.html#details">More...</a></p>

<p><code>#include &lt;ftl/concepts/monad.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1b089491c092b9a557698d104e3df106"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a1b089491c092b9a557698d104e3df106">T</a> = <a class="el" href="group__typelevel.html#ga3d10d966c41c9018bc34c6c51b4e994f">concept_parameter</a>&lt; M &gt;</td></tr>
<tr class="memdesc:a1b089491c092b9a557698d104e3df106"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type <code>M</code> is a monad on.  <a href="#a1b089491c092b9a557698d104e3df106">More...</a><br/></td></tr>
<tr class="separator:a1b089491c092b9a557698d104e3df106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16489eb59b8ada82a1a8b0aa0df653b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16489eb59b8ada82a1a8b0aa0df653b4"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a16489eb59b8ada82a1a8b0aa0df653b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a> = typename <a class="el" href="structftl_1_1re__parametrise.html">re_parametrise</a>&lt; M, U &gt;::type</td></tr>
<tr class="memdesc:a16489eb59b8ada82a1a8b0aa0df653b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient means of re parametrising M. <br/></td></tr>
<tr class="separator:a16489eb59b8ada82a1a8b0aa0df653b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acc337ad5bb79d4f4f764598aa31a2d75"><td class="memItemLeft" align="right" valign="top">static M&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#acc337ad5bb79d4f4f764598aa31a2d75">pure</a> (const <a class="el" href="structftl_1_1monad.html#a1b089491c092b9a557698d104e3df106">T</a> &amp;)</td></tr>
<tr class="memdesc:acc337ad5bb79d4f4f764598aa31a2d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate a "pure" value.  <a href="#acc337ad5bb79d4f4f764598aa31a2d75">More...</a><br/></td></tr>
<tr class="separator:acc337ad5bb79d4f4f764598aa31a2d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab019ea91046a37e49baaeeba836e831e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename U  = result_of&lt;F(T)&gt;&gt; </td></tr>
<tr class="memitem:ab019ea91046a37e49baaeeba836e831e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#ab019ea91046a37e49baaeeba836e831e">map</a> (F &amp;&amp;f, const M &amp;m)</td></tr>
<tr class="memdesc:ab019ea91046a37e49baaeeba836e831e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a function to a contextualised value.  <a href="#ab019ea91046a37e49baaeeba836e831e">More...</a><br/></td></tr>
<tr class="separator:ab019ea91046a37e49baaeeba836e831e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d9dc66d3ca1a73fa8dd42d427b7e15"><td class="memTemplParams" colspan="2">template&lt;typename Mf , typename F  = concept_parameter&lt;Mf&gt;, typename U  = result_of&lt;F(T)&gt;, typename  = typename std::enable_if&lt;					std::is_same&lt;M_&lt;F&gt;,Mf&gt;::value				&gt;::type&gt; </td></tr>
<tr class="memitem:a55d9dc66d3ca1a73fa8dd42d427b7e15"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a55d9dc66d3ca1a73fa8dd42d427b7e15">apply</a> (const Mf &amp;fn, const M &amp;m)</td></tr>
<tr class="memdesc:a55d9dc66d3ca1a73fa8dd42d427b7e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an encapsulated function to an encapsulated value.  <a href="#a55d9dc66d3ca1a73fa8dd42d427b7e15">More...</a><br/></td></tr>
<tr class="separator:a55d9dc66d3ca1a73fa8dd42d427b7e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaeca77ea0895c2a9fc72f33f5156347"><td class="memTemplParams" colspan="2">template&lt;typename F , typename U  = concept_parameter&lt;result_of&lt;F(T)&gt;&gt;&gt; </td></tr>
<tr class="memitem:aeaeca77ea0895c2a9fc72f33f5156347"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#aeaeca77ea0895c2a9fc72f33f5156347">bind</a> (const M &amp;m, F &amp;&amp;f)</td></tr>
<tr class="memdesc:aeaeca77ea0895c2a9fc72f33f5156347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a value and execute a computation in M on it.  <a href="#aeaeca77ea0895c2a9fc72f33f5156347">More...</a><br/></td></tr>
<tr class="separator:aeaeca77ea0895c2a9fc72f33f5156347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2d0feff47a94baf72931ae6270e3a3"><td class="memItemLeft" align="right" valign="top">static M&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a1f2d0feff47a94baf72931ae6270e3a3">join</a> (const <a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a>&lt; M &gt; &amp;m)</td></tr>
<tr class="memdesc:a1f2d0feff47a94baf72931ae6270e3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins (or "flattens") a nested instance of <code>M</code>.  <a href="#a1f2d0feff47a94baf72931ae6270e3a3">More...</a><br/></td></tr>
<tr class="separator:a1f2d0feff47a94baf72931ae6270e3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a33251863983348c6a23274c37b9833c4"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a33251863983348c6a23274c37b9833c4">instance</a> = false</td></tr>
<tr class="memdesc:a33251863983348c6a23274c37b9833c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for compile time checks.  <a href="#a33251863983348c6a23274c37b9833c4">More...</a><br/></td></tr>
<tr class="separator:a33251863983348c6a23274c37b9833c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename M&gt;<br/>
interface ftl::monad&lt; M &gt;</h3>

<p>Concrete definition of the monad concept. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1b089491c092b9a557698d104e3df106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; M &gt;::<a class="el" href="structftl_1_1monad.html#a1b089491c092b9a557698d104e3df106">T</a> =  <a class="el" href="group__typelevel.html#ga3d10d966c41c9018bc34c6c51b4e994f">concept_parameter</a>&lt;M&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type <code>M</code> is a monad on. </p>
<p>For example, in the case of <code>maybe&lt;int&gt;</code>, <code>T = int</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acc337ad5bb79d4f4f764598aa31a2d75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static M <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; M &gt;::pure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structftl_1_1monad.html#a1b089491c092b9a557698d104e3df106">T</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encapsulate a "pure" value. </p>
<p>Given a plain value, encapsulate it in the monad M.</p>
<dl class="section note"><dt>Note</dt><dd>All monad instances must define <code>pure</code>, it can not be derived.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structftl_1_1applicative.html#aa799f90c2b5e6936bc361cb2b96012b4" title="Encapsulate a pure value in the applicative functor.">applicative::pure</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab019ea91046a37e49baaeeba836e831e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename F , typename U  = result_of&lt;F(T)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a>&lt;U&gt; <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; M &gt;::map </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map a function to a contextualised value. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structftl_1_1functor.html#a8bea58a9814e5ab2a3b9ab019d68055b" title="Maps a function to the contained value(s).">functor::map</a>, <a class="el" href="structftl_1_1deriving__map.html" title="Inheritable implementation of monad&lt;M&gt;::map.">deriving_map</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a55d9dc66d3ca1a73fa8dd42d427b7e15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename Mf , typename F  = concept_parameter&lt;Mf&gt;, typename U  = result_of&lt;F(T)&gt;, typename  = typename std::enable_if&lt;					std::is_same&lt;M_&lt;F&gt;,Mf&gt;::value				&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a>&lt;U&gt; <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; M &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const Mf &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an encapsulated function to an encapsulated value. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structftl_1_1applicative.html#ae8261989c486235592c22dfc1705b132" title="Contextualised function application.">applicative::apply</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeaeca77ea0895c2a9fc72f33f5156347"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename F , typename U  = concept_parameter&lt;result_of&lt;F(T)&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a>&lt;U&gt; <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; M &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a value and execute a computation in M on it. </p>
<p>The bind operation is the basic operation used to sequence monadic computations. In essence, you can say that the left hand side is computed first (the definition of "computed" in this case depending on the particular instance of monad used), whereafter its result is "unwrapped" and fed to <code>f</code>, which in turn produces a new monadic computation. This second computation is returned, but never "run" (to keep it in the context of <code>M</code> and to allow further sequencing).</p>
<p>Instances are free to provide <code>bind</code> using move semantics on <code>M</code>, either in addition to <code>const</code> reference version, or instead of.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>must satisfy <a class="el" href="fn.html">Function</a><code>&lt;M_&lt;U&gt;(T)&gt;</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f2d0feff47a94baf72931ae6270e3a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static M <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; M &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structftl_1_1monad.html#a16489eb59b8ada82a1a8b0aa0df653b4">M_</a>&lt; M &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Joins (or "flattens") a nested instance of <code>M</code>. </p>
<p>This function is easy to gain an intuition for; it corresponds to e.g. making a list of lists into a plain old list by simply concatenating all the inner lists into a single long one. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a33251863983348c6a23274c37b9833c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; M &gt;::instance = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for compile time checks. </p>
<p>Implementors <em>must</em> override this default. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 27 2013 19:49:02 for FTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

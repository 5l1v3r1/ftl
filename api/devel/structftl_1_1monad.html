<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>FTL: ftl::monad&lt; M &gt; Interface Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FTL
   </div>
   <div id="projectbrief">The Functional Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ftl</b></li><li class="navelem"><a class="el" href="structftl_1_1monad.html">monad</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="interfaceftl_1_1monad-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ftl::monad&lt; M &gt; Interface Template Reference<div class="ingroups"><a class="el" href="group__monad.html">Monad</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Concrete definition of the monad concept.  
 <a href="structftl_1_1monad.html#details">More...</a></p>

<p><code>#include &lt;ftl/concepts/monad.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af2ee99ad3ebc736268589f3d09c1360a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af2ee99ad3ebc736268589f3d09c1360a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> = <a class="el" href="group__typelevel.html#ga79056a7116203f7a40e062470fa0ebc0">Rebind</a>&lt; M_, U &gt;</td></tr>
<tr class="memdesc:af2ee99ad3ebc736268589f3d09c1360a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides some sugar for referring to differently parametrised <code>M_</code>s.  <a href="#af2ee99ad3ebc736268589f3d09c1360a">More...</a><br/></td></tr>
<tr class="separator:af2ee99ad3ebc736268589f3d09c1360a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876898a369de99ec760c6d948c8eeace"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> = <a class="el" href="group__typelevel.html#ga2f48a207e596531a4293c950f9487381">Value_type</a>&lt; M_ &gt;</td></tr>
<tr class="memdesc:a876898a369de99ec760c6d948c8eeace"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type <code>M</code> is a monad on.  <a href="#a876898a369de99ec760c6d948c8eeace">More...</a><br/></td></tr>
<tr class="separator:a876898a369de99ec760c6d948c8eeace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1cd11ecbd6f23192edb85131d6f07976"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a1cd11ecbd6f23192edb85131d6f07976">pure</a> (const <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &amp;)</td></tr>
<tr class="memdesc:a1cd11ecbd6f23192edb85131d6f07976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulate a "pure" value.  <a href="#a1cd11ecbd6f23192edb85131d6f07976">More...</a><br/></td></tr>
<tr class="separator:a1cd11ecbd6f23192edb85131d6f07976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244ec1c78bf83022a2c90ff9cfca09aa"><td class="memTemplParams" colspan="2">template&lt;typename F , typename U  = result_of&lt;F(T)&gt;&gt; </td></tr>
<tr class="memitem:a244ec1c78bf83022a2c90ff9cfca09aa"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a244ec1c78bf83022a2c90ff9cfca09aa">map</a> (F &amp;&amp;f, const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt; &amp;m)</td></tr>
<tr class="memdesc:a244ec1c78bf83022a2c90ff9cfca09aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a function to a contextualised value.  <a href="#a244ec1c78bf83022a2c90ff9cfca09aa">More...</a><br/></td></tr>
<tr class="separator:a244ec1c78bf83022a2c90ff9cfca09aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65af0eee0dda84ab33a84bcec32e1b54"><td class="memTemplParams" colspan="2">template&lt;typename F , typename U  = result_of&lt;F(T)&gt;&gt; </td></tr>
<tr class="memitem:a65af0eee0dda84ab33a84bcec32e1b54"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a65af0eee0dda84ab33a84bcec32e1b54">apply</a> (const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; F &gt; &amp;fn, const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt; &amp;m)</td></tr>
<tr class="memdesc:a65af0eee0dda84ab33a84bcec32e1b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an encapsulated function to an encapsulated value.  <a href="#a65af0eee0dda84ab33a84bcec32e1b54">More...</a><br/></td></tr>
<tr class="separator:a65af0eee0dda84ab33a84bcec32e1b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0272e9f5bedd828febd1293c50155442"><td class="memTemplParams" colspan="2">template&lt;typename F , typename U  = Value_type&lt;result_of&lt;F(T)&gt;&gt;&gt; </td></tr>
<tr class="memitem:a0272e9f5bedd828febd1293c50155442"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a0272e9f5bedd828febd1293c50155442">bind</a> (const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt; &amp;m, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a0272e9f5bedd828febd1293c50155442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a value and execute a computation in <code>M</code> on it.  <a href="#a0272e9f5bedd828febd1293c50155442">More...</a><br/></td></tr>
<tr class="separator:a0272e9f5bedd828febd1293c50155442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9c4114296be67f76f887799a3ffed1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#ace9c4114296be67f76f887799a3ffed1">join</a> (const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt;&gt; &amp;m)</td></tr>
<tr class="memdesc:ace9c4114296be67f76f887799a3ffed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins (or "flattens") a nested instance of <code>M</code>.  <a href="#ace9c4114296be67f76f887799a3ffed1">More...</a><br/></td></tr>
<tr class="separator:ace9c4114296be67f76f887799a3ffed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a33251863983348c6a23274c37b9833c4"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html#a33251863983348c6a23274c37b9833c4">instance</a> = false</td></tr>
<tr class="memdesc:a33251863983348c6a23274c37b9833c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for compile time checks.  <a href="#a33251863983348c6a23274c37b9833c4">More...</a><br/></td></tr>
<tr class="separator:a33251863983348c6a23274c37b9833c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename M&gt;<br/>
interface ftl::monad&lt; M &gt;</h3>

<p>Concrete definition of the monad concept. </p>
<dl class="section user"><dt>Writing A New Instance</dt><dd>To create a monad implementation for a user defines type, you need to specialise the <code>struct</code> that defines this interface. In general, this will look something akin to:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>monad&lt;MyType&lt;<a class="code" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace" title="The type M is a monad on. ">T</a>&gt;&gt; {</div>
<div class="line">    <span class="comment">// Implementation goes here</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>For details about the various monadic operations that should be part of the implementation, simply refer to the rest of the documentation of this interface. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af2ee99ad3ebc736268589f3d09c1360a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> &gt;::<a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> =  <a class="el" href="group__typelevel.html#ga79056a7116203f7a40e062470fa0ebc0">Rebind</a>&lt;M_,U&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides some sugar for referring to differently parametrised <code>M_</code>s. </p>
<p>This results in much cleaner type signatures. </p>

</div>
</div>
<a class="anchor" id="a876898a369de99ec760c6d948c8eeace"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> &gt;::<a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> =  <a class="el" href="group__typelevel.html#ga2f48a207e596531a4293c950f9487381">Value_type</a>&lt;M_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type <code>M</code> is a monad on. </p>
<p>For example, in the case of <code>maybe&lt;int&gt;</code>, <code>T = int</code>. In the general case, <code>T</code> depends on how (if at all) <code>M</code> specialises the <code>parametric_traits</code> struct. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1cd11ecbd6f23192edb85131d6f07976"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt;<a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a>&gt; <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> &gt;::pure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &amp;&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encapsulate a "pure" value. </p>
<p>Given a plain value, encapsulate it in the monad <code>M</code>.</p>
<dl class="section note"><dt>Note</dt><dd>All monad instances must define <code>pure</code>, it can not be derived.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structftl_1_1applicative.html#ac861748b7c54a0a145350bfaddce0bbd" title="Encapsulate a pure value in the applicative functor. ">applicative::pure</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a244ec1c78bf83022a2c90ff9cfca09aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename F , typename U  = result_of&lt;F(T)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt;U&gt; <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> &gt;::map </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map a function to a contextualised value. </p>
<p>Depending on how you decide to view a monad, <code>map</code> could be interpreted to mean e.g. either of:</p>
<ul>
<li>Apply <code>f</code> to every element contained in <code>m</code> and return a new container of all the results.</li>
<li>Return a computation that is the result of running the computation <code>m</code> and then applying <code>f</code> to that result.</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structftl_1_1functor.html#acb7ce8fddca669add055812ad5ffaee4" title="Maps a function to the contained value(s). ">functor::map</a>, deriving_map </dd></dl>

</div>
</div>
<a class="anchor" id="a65af0eee0dda84ab33a84bcec32e1b54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename F , typename U  = result_of&lt;F(T)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt;U&gt; <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; F &gt; &amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies an encapsulated function to an encapsulated value. </p>
<p>Somewhat similar to <code>map</code>, except in this case the function <code>f</code> is also wrapped in a monadic context. I.e., in the case of the list monad, <code>fn</code> would be a list of functions; in the case of <code><a class="el" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe</a></code>, it would <em>maybe</em> be a function; and so on.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structftl_1_1applicative.html#aa6e598d0584e8f8218ea93eb2bc0bbbf" title="Contextualised function application. ">applicative::apply</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0272e9f5bedd828febd1293c50155442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename F , typename U  = Value_type&lt;result_of&lt;F(T)&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt;U&gt; <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a value and execute a computation in <code>M</code> on it. </p>
<p>The bind operation is the basic operation used to sequence monadic computations. In essence, you can say that the left hand side is computed first (the definition of "computed" in this case depending on the particular instance of monad used), whereafter its result is "unwrapped" and fed to <code>f</code>, which in turn produces a new monadic computation. This second computation is returned, but not "run" (to keep it in the context of <code>M</code> and to allow further sequencing).</p>
<p>Instances are free to provide <code>bind</code> using move semantics on <code>M</code>, either in addition to <code>const</code> reference version, or instead of.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>must satisfy fn<code></code>&lt;M&lt;U&gt;(T)&gt; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace9c4114296be67f76f887799a3ffed1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt;<a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a>&gt; <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> &gt;::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a>&lt; <a class="el" href="structftl_1_1monad.html#a876898a369de99ec760c6d948c8eeace">T</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Joins (or "flattens") a nested instance of <code>M</code>. </p>
<p>This function is easy to gain an intuition for; it corresponds to e.g. making a list of lists into a plain old list by simply concatenating all the inner lists into a single long one. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a33251863983348c6a23274c37b9833c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="structftl_1_1monad.html">ftl::monad</a>&lt; <a class="el" href="structftl_1_1monad.html#af2ee99ad3ebc736268589f3d09c1360a">M</a> &gt;::instance = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for compile time checks. </p>
<p>Implementors <em>must</em> override this default. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 7 2013 17:07:05 for FTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>

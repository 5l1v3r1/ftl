<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>FTL: Prelude</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FTL
   </div>
   <div id="projectbrief">The Functional Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Prelude</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of utilities and functions, typically useful in combination with the other, more specialised FTL modules.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1identity.html">ftl::identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identity function object.  <a href="structftl_1_1identity.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1inplace__tag.html">ftl::inplace_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to distinguish in-place constructors from others.  <a href="structftl_1_1inplace__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1constant.html">ftl::constant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant function object.  <a href="structftl_1_1constant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga89d77da09bb3cb52673e3717538a1745"><td class="memTemplParams" colspan="2">template&lt;bool Pred&gt; </td></tr>
<tr class="memitem:ga89d77da09bb3cb52673e3717538a1745"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga89d77da09bb3cb52673e3717538a1745">ftl::Requires</a> = typename std::enable_if&lt; Pred &gt;::type</td></tr>
<tr class="memdesc:ga89d77da09bb3cb52673e3717538a1745"><td class="mdescLeft">&#160;</td><td class="mdescRight">A short-hand alias of <code>std::enable_if</code>.  <a href="#ga89d77da09bb3cb52673e3717538a1745">More...</a><br/></td></tr>
<tr class="separator:ga89d77da09bb3cb52673e3717538a1745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7e4340316111a4e484d003e07bc29494"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:ga7e4340316111a4e484d003e07bc29494"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga7e4340316111a4e484d003e07bc29494">ftl::tuple_apply</a> (F &amp;&amp;f, const std::tuple&lt; Ts...&gt; &amp;t) -&gt; typename std::result_of&lt; F(Ts...)&gt;::type</td></tr>
<tr class="memdesc:ga7e4340316111a4e484d003e07bc29494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke a function using a tuple's fields as parameters.  <a href="#ga7e4340316111a4e484d003e07bc29494">More...</a><br/></td></tr>
<tr class="separator:ga7e4340316111a4e484d003e07bc29494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac206778a06dd18bb42fbe28cc6fca649"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac206778a06dd18bb42fbe28cc6fca649"></a>
template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:gac206778a06dd18bb42fbe28cc6fca649"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#gac206778a06dd18bb42fbe28cc6fca649">ftl::tuple_apply</a> (F &amp;&amp;f, std::tuple&lt; Ts...&gt; &amp;&amp;t) -&gt; typename std::result_of&lt; F(Ts...)&gt;::type</td></tr>
<tr class="memdesc:gac206778a06dd18bb42fbe28cc6fca649"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gac206778a06dd18bb42fbe28cc6fca649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18d2a5ec6bf2b8e20e978d337aec772c"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P1 , typename P2 , typename... Ps&gt; </td></tr>
<tr class="memitem:ga18d2a5ec6bf2b8e20e978d337aec772c"><td class="memTemplItemLeft" align="right" valign="top">function&lt; R(P1, P2, Ps...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga18d2a5ec6bf2b8e20e978d337aec772c">ftl::curry</a> (R(*f)(P1, P2, Ps...))</td></tr>
<tr class="memdesc:ga18d2a5ec6bf2b8e20e978d337aec772c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curries an n-ary function pointer.  <a href="#ga18d2a5ec6bf2b8e20e978d337aec772c">More...</a><br/></td></tr>
<tr class="separator:ga18d2a5ec6bf2b8e20e978d337aec772c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94263d6dc263a4cf459d9632c58038d"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae94263d6dc263a4cf459d9632c58038d"></a>
template&lt;typename R , typename P1 , typename P2 , typename... Ps&gt; </td></tr>
<tr class="memitem:gae94263d6dc263a4cf459d9632c58038d"><td class="memTemplItemLeft" align="right" valign="top">function&lt; R(P1, P2, Ps...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#gae94263d6dc263a4cf459d9632c58038d">ftl::curry</a> (const std::function&lt; R(P1, P2, Ps...)&gt; &amp;f)</td></tr>
<tr class="memdesc:gae94263d6dc263a4cf459d9632c58038d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gae94263d6dc263a4cf459d9632c58038d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343be151c1cdeb81c1746c0a6e506732"><td class="memTemplParams" colspan="2">template&lt;typename F , typename  = Requires&lt;!is_monomorphic&lt;plain_type&lt;F&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga343be151c1cdeb81c1746c0a6e506732"><td class="memTemplItemLeft" align="right" valign="top">implementation_defined&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga343be151c1cdeb81c1746c0a6e506732">ftl::curry</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ga343be151c1cdeb81c1746c0a6e506732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curries arbitrary function objects.  <a href="#ga343be151c1cdeb81c1746c0a6e506732">More...</a><br/></td></tr>
<tr class="separator:ga343be151c1cdeb81c1746c0a6e506732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5447e27f486a87e54568cffd52a8c83c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5447e27f486a87e54568cffd52a8c83c"></a>
template&lt;typename R , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga5447e27f486a87e54568cffd52a8c83c"><td class="memTemplItemLeft" align="right" valign="top">function&lt; R(T1, T2)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga5447e27f486a87e54568cffd52a8c83c">ftl::uncurry</a> (function&lt; function&lt; R(T2)&gt;(T1)&gt; f)</td></tr>
<tr class="memdesc:ga5447e27f486a87e54568cffd52a8c83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncurries a binary function. <br/></td></tr>
<tr class="separator:ga5447e27f486a87e54568cffd52a8c83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3cbca8d63476f096496e7e8db78bf6e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename A , typename B  = typename std::result_of&lt;F(A)&gt;::type, typename... Ps&gt; </td></tr>
<tr class="memitem:gac3cbca8d63476f096496e7e8db78bf6e"><td class="memTemplItemLeft" align="right" valign="top">function&lt; B(Ps...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#gac3cbca8d63476f096496e7e8db78bf6e">ftl::compose</a> (F f, A(*fn)(Ps...))</td></tr>
<tr class="memdesc:gac3cbca8d63476f096496e7e8db78bf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function composition first base case.  <a href="#gac3cbca8d63476f096496e7e8db78bf6e">More...</a><br/></td></tr>
<tr class="separator:gac3cbca8d63476f096496e7e8db78bf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e082ebcaa7e7aab98c5a64ded4f2fc0"><td class="memTemplParams" colspan="2">template&lt;typename F , typename A , typename B  = typename std::result_of&lt;F(A)&gt;::type, typename... Ps&gt; </td></tr>
<tr class="memitem:ga4e082ebcaa7e7aab98c5a64ded4f2fc0"><td class="memTemplItemLeft" align="right" valign="top">function&lt; B(Ps...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga4e082ebcaa7e7aab98c5a64ded4f2fc0">ftl::compose</a> (F f, function&lt; A(Ps...)&gt; fn)</td></tr>
<tr class="memdesc:ga4e082ebcaa7e7aab98c5a64ded4f2fc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function composition second base case.  <a href="#ga4e082ebcaa7e7aab98c5a64ded4f2fc0">More...</a><br/></td></tr>
<tr class="separator:ga4e082ebcaa7e7aab98c5a64ded4f2fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad0a02e3e3b2fc440d2deeee87a20dd"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Fs&gt; </td></tr>
<tr class="memitem:ga6ad0a02e3e3b2fc440d2deeee87a20dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga6ad0a02e3e3b2fc440d2deeee87a20dd">ftl::compose</a> (F &amp;&amp;f, Fs &amp;&amp;...fs) -&gt; decltype(compose(std::forward&lt; F &gt;(f), compose(std::forward&lt; Fs &gt;(fs)...)))</td></tr>
<tr class="memdesc:ga6ad0a02e3e3b2fc440d2deeee87a20dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalised, n-ary function composition.  <a href="#ga6ad0a02e3e3b2fc440d2deeee87a20dd">More...</a><br/></td></tr>
<tr class="separator:ga6ad0a02e3e3b2fc440d2deeee87a20dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f4bf318e5677f7af465ae7493e5c03"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae1f4bf318e5677f7af465ae7493e5c03"></a>
template&lt;typename A , typename B , typename R &gt; </td></tr>
<tr class="memitem:gae1f4bf318e5677f7af465ae7493e5c03"><td class="memTemplItemLeft" align="right" valign="top">function&lt; R(B, A)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#gae1f4bf318e5677f7af465ae7493e5c03">ftl::flip</a> (function&lt; R(A, B)&gt; f)</td></tr>
<tr class="memdesc:gae1f4bf318e5677f7af465ae7493e5c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the parameter order of a binary function. <br/></td></tr>
<tr class="separator:gae1f4bf318e5677f7af465ae7493e5c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f92a8bf53c3f1fb822f12bccd595409"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0f92a8bf53c3f1fb822f12bccd595409"></a>
template&lt;typename A , typename B , typename R &gt; </td></tr>
<tr class="memitem:ga0f92a8bf53c3f1fb822f12bccd595409"><td class="memTemplItemLeft" align="right" valign="top">function&lt; R(B, A)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga0f92a8bf53c3f1fb822f12bccd595409">ftl::flip</a> (R(&amp;f)(A, B))</td></tr>
<tr class="memdesc:ga0f92a8bf53c3f1fb822f12bccd595409"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga0f92a8bf53c3f1fb822f12bccd595409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df628d8c99f3fc40ebf60eceebb30ea"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2df628d8c99f3fc40ebf60eceebb30ea"></a>
template&lt;typename R , typename A , typename B &gt; </td></tr>
<tr class="memitem:ga2df628d8c99f3fc40ebf60eceebb30ea"><td class="memTemplItemLeft" align="right" valign="top">function&lt; function&lt; R(A)&gt;B)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga2df628d8c99f3fc40ebf60eceebb30ea">ftl::flip</a> (function&lt; function&lt; R(B)&gt;(A)&gt; f)</td></tr>
<tr class="memdesc:ga2df628d8c99f3fc40ebf60eceebb30ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip parameter order of a curried binary function. <br/></td></tr>
<tr class="separator:ga2df628d8c99f3fc40ebf60eceebb30ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8d2a349f8ef51a479398627807f0db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2f8d2a349f8ef51a479398627807f0db"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga2f8d2a349f8ef51a479398627807f0db">ftl::ForwardIterable</a> ()</td></tr>
<tr class="memdesc:ga2f8d2a349f8ef51a479398627807f0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time check for <a class="el" href="fwditerable.html">ForwardIterable</a> instances.  <a href="#ga2f8d2a349f8ef51a479398627807f0db">More...</a><br/></td></tr>
<tr class="separator:ga2f8d2a349f8ef51a479398627807f0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae0b06fcc8b38dd802352589bf3bec96d"><td class="memItemLeft" align="right" valign="top">constexpr identity&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prelude.html#gae0b06fcc8b38dd802352589bf3bec96d">ftl::id</a> {}</td></tr>
<tr class="memdesc:gae0b06fcc8b38dd802352589bf3bec96d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time instance of identity.  <a href="#gae0b06fcc8b38dd802352589bf3bec96d">More...</a><br/></td></tr>
<tr class="separator:gae0b06fcc8b38dd802352589bf3bec96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga226737232bdced653cbbd6113a0995f3"><td class="memItemLeft" align="right" valign="top">constexpr constant&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__prelude.html#ga226737232bdced653cbbd6113a0995f3">ftl::const_</a></td></tr>
<tr class="memdesc:ga226737232bdced653cbbd6113a0995f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time instance of a <code>constant</code> function object.  <a href="#ga226737232bdced653cbbd6113a0995f3">More...</a><br/></td></tr>
<tr class="separator:ga226737232bdced653cbbd6113a0995f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A collection of utilities and functions, typically useful in combination with the other, more specialised FTL modules. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ftl/prelude.h&gt;</span></div>
</div><!-- fragment --><dl class="section user"><dt>Dependencies</dt><dd><ul>
<li>&lt;tuple&gt;</li>
<li>&lt;ftl/type_traits.h&gt;</li>
<li>&lt;ftl/function.h&gt; </li>
</ul>
</dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga89d77da09bb3cb52673e3717538a1745"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Pred&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__prelude.html#ga89d77da09bb3cb52673e3717538a1745">ftl::Requires</a> = typedef typename std::enable_if&lt;Pred&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A short-hand alias of <code>std::enable_if</code>. </p>
<dl class="section note"><dt>Note</dt><dd>Consider this a temporary solution until concepts lite or something similar becomes readily available. As soon as that comes to pass, this construct will be considered deprecated.</dd></dl>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> = Requires&lt;Monad&lt;M&gt;()&gt;&gt;</div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> M&amp; m) {</div>
<div class="line">    <span class="comment">// Safely perform monadic operations on m</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7e4340316111a4e484d003e07bc29494"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::tuple_apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; Ts...&gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename std::result_of&lt;F(Ts...)&gt;::type </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke a function using a tuple's fields as parameters. </p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">int</span>, <span class="keywordtype">float</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Invokes foo with 1 and 2.f as arguments</span></div>
<div class="line"><a class="code" href="group__prelude.html#ga7e4340316111a4e484d003e07bc29494" title="Invoke a function using a tuple&#39;s fields as parameters. ">ftl::tuple_apply</a>(foo, std::make_tuple(1, 2.f));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga18d2a5ec6bf2b8e20e978d337aec772c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P1 , typename P2 , typename... Ps&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function&lt;R(P1,P2,Ps...)&gt; ftl::curry </td>
          <td>(</td>
          <td class="paramtype">R(*)(P1, P2, Ps...)&#160;</td>
          <td class="paramname"><em>f</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curries an n-ary function pointer. </p>
<p>Currying is the process of turning a function of e.g. <code>(a,b) -&gt; c</code> into <code>(a) -&gt; ((b) -&gt; c)</code>. In other words, instead of taking two arguments and returning the answer, the curried function takes one argument and returns a function that takes another one and <em>then</em> returns the answer.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is actually exactly equivalent of wrapping the function in an <a class="el" href="classftl_1_1function.html" title="Function object encapsulator. ">ftl::function</a> object, as those support curried calling by default. </dd></dl>

</div>
</div>
<a class="anchor" id="ga343be151c1cdeb81c1746c0a6e506732"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename  = Requires&lt;!is_monomorphic&lt;plain_type&lt;F&gt;&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">implementation_defined ftl::curry </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curries arbitrary function objects. </p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> f = [](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z){ <span class="keywordflow">return</span> x+y-z; };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> g = <a class="code" href="group__prelude.html#ga18d2a5ec6bf2b8e20e978d337aec772c" title="Curries an n-ary function pointer. ">ftl::curry</a>(f);</div>
<div class="line"></div>
<div class="line"><span class="comment">// g(1, 2, 3) == g(1, 2)(3) == g(1)(2, 3) == g(1)(2)(3)</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Because this version of <code>curry</code> works on arbitrary function objects with unknown and possibly multiple, overloaded <code>operator()</code>s, there is no way to force the result of <code>curry</code> to accept only matching types. If you give a curried function object parameters that does not match any of its <code>operator()</code>s, it will simply never be invoked, it will just continue to accumulate parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3cbca8d63476f096496e7e8db78bf6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename A , typename B  = typename std::result_of&lt;F(A)&gt;::type, typename... Ps&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function&lt;B(Ps...)&gt; ftl::compose </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A(*)(Ps...)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function composition first base case. </p>
<p>Composes an arbitrary function object with a function pointer. </p>

</div>
</div>
<a class="anchor" id="ga4e082ebcaa7e7aab98c5a64ded4f2fc0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename A , typename B  = typename std::result_of&lt;F(A)&gt;::type, typename... Ps&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">function&lt;B(Ps...)&gt; ftl::compose </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; A(Ps...)&gt;&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function composition second base case. </p>
<p>Composes an arbitrary function object with an <a class="el" href="classftl_1_1function.html" title="Function object encapsulator. ">ftl::function</a>. </p>

</div>
</div>
<a class="anchor" id="ga6ad0a02e3e3b2fc440d2deeee87a20dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::compose </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>fs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(compose(std::forward&lt;F&gt;(f), compose(std::forward&lt;Fs&gt;(fs)...))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generalised, n-ary function composition. </p>
<p>Composes an arbitrary number of functions, where each function's return value is piped to the next. The right-most function in the sequence is the first to be evaluated and its result is passed to the one step to the left. Return values must match parameter type of the next one in the chain. </p>

</div>
</div>
<a class="anchor" id="ga2f8d2a349f8ef51a479398627807f0db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ftl::ForwardIterable </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile time check for <a class="el" href="fwditerable.html">ForwardIterable</a> instances. </p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;</div>
<div class="line">    <span class="keyword">typename</span> Container,</div>
<div class="line">    <span class="keyword">typename</span> = <a class="code" href="group__prelude.html#ga89d77da09bb3cb52673e3717538a1745" title="A short-hand alias of std::enable_if. ">Requires</a>&lt;</div>
<div class="line">        ForwardIterable&lt;Container&gt;()</div>
<div class="line">    &gt;</div>
<div class="line">&gt;</div>
<div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> Container&amp; c) {</div>
<div class="line">    <span class="comment">// Safe to iterate with e.g. for(auto&amp; e : c)</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gae0b06fcc8b38dd802352589bf3bec96d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr identity ftl::id {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile time instance of identity. </p>
<p>Makes passing the identity function to higher order functions even more convenient.</p>
<p>Example usage: </p>
<div class="fragment"><div class="line"><span class="comment">// Does nothing; v will be {1,2,3}</span></div>
<div class="line"><span class="keyword">auto</span> v = <a class="code" href="group__functor.html#ga3b47f156f02c00475cf2cb030c6ea565" title="Function object representing functor::map. ">ftl::fmap</a>(<a class="code" href="group__prelude.html#gae0b06fcc8b38dd802352589bf3bec96d" title="Compile time instance of identity. ">ftl::id</a>, std::vector&lt;int&gt;{1,2,3});</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga226737232bdced653cbbd6113a0995f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr constant ftl::const_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile time instance of a <code>constant</code> function object. </p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>A simple example: </p>
<div class="fragment"><div class="line"><a class="code" href="group__functor.html#ga3b47f156f02c00475cf2cb030c6ea565" title="Function object representing functor::map. ">ftl::fmap</a>(<a class="code" href="group__prelude.html#ga226737232bdced653cbbd6113a0995f3" title="Compile time instance of a constant function object. ">const_</a>(42), std::list&lt;int&gt;{1,2,3}); <span class="comment">// {42, 42, 42}</span></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 7 2013 17:07:05 for FTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>

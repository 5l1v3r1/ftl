<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>FTL: Monad</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FTL
   </div>
   <div id="projectbrief">The Functional Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Monad</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="monadpg.html">Monad</a> concept and related functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1in__terms__of__bind.html">ftl::in_terms_of_bind&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag that can be used to specify which concept implementation to derive.  <a href="structftl_1_1in__terms__of__bind.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__join_3_01in__terms__of__bind_3_01M_01_4_01_4.html">ftl::deriving_join&lt; in_terms_of_bind&lt; M &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable implementation of <code><a class="el" href="structftl_1_1monad.html#ace9c4114296be67f76f887799a3ffed1" title="Joins (or &quot;flattens&quot;) a nested instance of M. ">monad::join</a></code>.  <a href="structftl_1_1deriving__join_3_01in__terms__of__bind_3_01M_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__map_3_01in__terms__of__bind_3_01M_01_4_01_4.html">ftl::deriving_map&lt; in_terms_of_bind&lt; M &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable implementation of <code><a class="el" href="structftl_1_1monad.html#a244ec1c78bf83022a2c90ff9cfca09aa" title="Map a function to a contextualised value. ">monad::map</a></code>.  <a href="structftl_1_1deriving__map_3_01in__terms__of__bind_3_01M_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__bind.html">ftl::deriving_bind&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable implementation of <code><a class="el" href="structftl_1_1monad.html#a0272e9f5bedd828febd1293c50155442" title="Bind a value and execute a computation in M on it. ">monad::bind</a></code>.  <a href="structftl_1_1deriving__bind.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__bind_3_01back__insertable__container_3_01M___01_4_01_4.html">ftl::deriving_bind&lt; back_insertable_container&lt; M_ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable <code>bind</code> implementation for containers supporting <code>insert</code>.  <a href="structftl_1_1deriving__bind_3_01back__insertable__container_3_01M___01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__apply_3_01in__terms__of__bind_3_01M_01_4_01_4.html">ftl::deriving_apply&lt; in_terms_of_bind&lt; M &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable implementation of <code><a class="el" href="structftl_1_1monad.html#a65af0eee0dda84ab33a84bcec32e1b54" title="Applies an encapsulated function to an encapsulated value. ">monad::apply</a></code>.  <a href="structftl_1_1deriving__apply_3_01in__terms__of__bind_3_01M_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__monad_3_01back__insertable__container_3_01M_01_4_01_4.html">ftl::deriving_monad&lt; back_insertable_container&lt; M &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable monad implementation for many containers.  <a href="structftl_1_1deriving__monad_3_01back__insertable__container_3_01M_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html">ftl::monad&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete definition of the monad concept.  <a href="structftl_1_1monad.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga92286d3048dfcd17b02d10d70567c7ec"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:ga92286d3048dfcd17b02d10d70567c7ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga92286d3048dfcd17b02d10d70567c7ec">ftl::Monad</a> () noexcept</td></tr>
<tr class="memdesc:ga92286d3048dfcd17b02d10d70567c7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate to check whether a type is an instance of Monad.  <a href="#ga92286d3048dfcd17b02d10d70567c7ec">More...</a><br/></td></tr>
<tr class="separator:ga92286d3048dfcd17b02d10d70567c7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635fb0423f67f8ee065fedc9fb7763e4"><td class="memTemplParams" colspan="2">template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = Requires&lt;Monad&lt;M_&gt;()&gt;&gt; </td></tr>
<tr class="memitem:ga635fb0423f67f8ee065fedc9fb7763e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga635fb0423f67f8ee065fedc9fb7763e4">ftl::operator&gt;&gt;=</a> (M &amp;&amp;m, F &amp;&amp;f) -&gt; decltype(monad&lt; M_ &gt;::bind(std::forward&lt; M &gt;(m), std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:ga635fb0423f67f8ee065fedc9fb7763e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience operator for <code>ftl::mbind</code>.  <a href="#ga635fb0423f67f8ee065fedc9fb7763e4">More...</a><br/></td></tr>
<tr class="separator:ga635fb0423f67f8ee065fedc9fb7763e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b7affb4bcd880f03be8e06b2df3dbb"><td class="memTemplParams" colspan="2">template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = Requires&lt;Monad&lt;M_&gt;()&gt;&gt; </td></tr>
<tr class="memitem:gaa5b7affb4bcd880f03be8e06b2df3dbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaa5b7affb4bcd880f03be8e06b2df3dbb">ftl::operator&lt;&lt;=</a> (F &amp;&amp;f, M &amp;&amp;m) -&gt; decltype(monad&lt; M_ &gt;::bind(std::forward&lt; M &gt;(m), std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:gaa5b7affb4bcd880f03be8e06b2df3dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience operator for <a class="el" href="structftl_1_1monad.html#a0272e9f5bedd828febd1293c50155442" title="Bind a value and execute a computation in M on it. ">monad::bind</a>.  <a href="#gaa5b7affb4bcd880f03be8e06b2df3dbb">More...</a><br/></td></tr>
<tr class="separator:gaa5b7affb4bcd880f03be8e06b2df3dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69e01a4b56024be56f7be175e0cd5ed"><td class="memTemplParams" colspan="2">template&lt;typename Mt , typename Mu , typename Mt_  = plain_type&lt;Mt&gt;, typename T  = Value_type&lt;Mt_&gt;, typename  = Requires&lt;Monad&lt;Mt_&gt;()&gt;, typename  = Requires&lt;				std::is_same&lt;Rebind&lt;Mu,T&gt;, Mt_&gt;::value			&gt;&gt; </td></tr>
<tr class="memitem:gaa69e01a4b56024be56f7be175e0cd5ed"><td class="memTemplItemLeft" align="right" valign="top">Mu&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaa69e01a4b56024be56f7be175e0cd5ed">ftl::operator&gt;&gt;</a> (Mt &amp;&amp;m1, const Mu &amp;m2)</td></tr>
<tr class="memdesc:gaa69e01a4b56024be56f7be175e0cd5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform two monadic computations, discard result of first.  <a href="#gaa69e01a4b56024be56f7be175e0cd5ed">More...</a><br/></td></tr>
<tr class="separator:gaa69e01a4b56024be56f7be175e0cd5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8f608949a64546f8006329ea242451"><td class="memTemplParams" colspan="2">template&lt;typename Mt , typename Mu , typename  = Requires&lt;Monad&lt;Mt&gt;()&gt;, typename T  = Value_type&lt;Mt&gt;, typename U  = Value_type&lt;Mu&gt;, typename  = Requires&lt;				std::is_same&lt;Rebind&lt;Mu,T&gt;, Mt&gt;::value			&gt;&gt; </td></tr>
<tr class="memitem:ga4d8f608949a64546f8006329ea242451"><td class="memTemplItemLeft" align="right" valign="top">Mt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga4d8f608949a64546f8006329ea242451">ftl::operator&lt;&lt;</a> (const Mt &amp;m1, Mu m2)</td></tr>
<tr class="memdesc:ga4d8f608949a64546f8006329ea242451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence two monadic computations, return the first.  <a href="#ga4d8f608949a64546f8006329ea242451">More...</a><br/></td></tr>
<tr class="separator:ga4d8f608949a64546f8006329ea242451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7f4d96431ece1459b333109ad576de1e"><td class="memItemLeft" align="right" valign="top">struct ftl::ImplementationDefined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#ga7f4d96431ece1459b333109ad576de1e">ftl::mbind</a></td></tr>
<tr class="memdesc:ga7f4d96431ece1459b333109ad576de1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curried function object representing <code><a class="el" href="structftl_1_1monad.html#a0272e9f5bedd828febd1293c50155442" title="Bind a value and execute a computation in M on it. ">monad::bind</a></code>.  <a href="#ga7f4d96431ece1459b333109ad576de1e">More...</a><br/></td></tr>
<tr class="separator:ga7f4d96431ece1459b333109ad576de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0a7f9bec7789fa8d6d4c8743e7ba90"><td class="memItemLeft" align="right" valign="top">struct ftl::ImplementationDefined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#ga7c0a7f9bec7789fa8d6d4c8743e7ba90">ftl::mjoin</a></td></tr>
<tr class="memdesc:ga7c0a7f9bec7789fa8d6d4c8743e7ba90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object representing <code><a class="el" href="structftl_1_1monad.html#ace9c4114296be67f76f887799a3ffed1" title="Joins (or &quot;flattens&quot;) a nested instance of M. ">monad::join</a></code>.  <a href="#ga7c0a7f9bec7789fa8d6d4c8743e7ba90">More...</a><br/></td></tr>
<tr class="separator:ga7c0a7f9bec7789fa8d6d4c8743e7ba90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="monadpg.html">Monad</a> concept and related functions. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ftl/concepts/monad.h&gt;</span></div>
</div><!-- fragment --><dl class="section user"><dt>Dependencies</dt><dd><ul>
<li><a class="el" href="group__prelude.html">Prelude</a></li>
<li><a class="el" href="group__applicative.html">Applicative Functor</a> </li>
</ul>
</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga92286d3048dfcd17b02d10d70567c7ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ftl::Monad </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate to check whether a type is an instance of Monad. </p>
<p>Naturally, this predicate can already be used in conjunction with SFINAE to hide particular functions, methods, and classes/structs if a template parameter is not a Monad.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;</div>
<div class="line">    <span class="keyword">typename</span> M,</div>
<div class="line">    <span class="keyword">typename</span> = Requires&lt;Monad&lt;M&gt;()&gt;</div>
<div class="line">&gt;</div>
<div class="line"><span class="keywordtype">void</span> myFunc(<span class="keyword">const</span> M&amp; m) {</div>
<div class="line">    <span class="comment">// Use bind, join, apply, etc on m</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga635fb0423f67f8ee065fedc9fb7763e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = Requires&lt;Monad&lt;M_&gt;()&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(monad&lt;M_&gt;::bind(std::forward&lt;M&gt;(m), std::forward&lt;F&gt;(f))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience operator for <code>ftl::mbind</code>. </p>
<p>The following substitution is always true: </p>
<div class="fragment"><div class="line">a &gt;&gt;= b &lt;=&gt; <a class="code" href="group__monad.html#ga7f4d96431ece1459b333109ad576de1e" title="Curried function object representing monad::bind. ">ftl::mbind</a>(a, b)</div>
</div><!-- fragment --><p>The purpose is to make it more easy to read and write monadic code. All arguments are perfectly forwarded, for cases where it matters if the const reference or r-value reference version of <code>bind</code> is triggered.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<div class="fragment"><div class="line"><a class="code" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe&lt;int&gt;</a> maybeGetInt();</div>
<div class="line"><a class="code" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe&lt;float&gt;</a> mightFail(<span class="keywordtype">int</span>);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe&lt;float&gt;</a> example() {</div>
<div class="line">    <span class="keywordflow">return</span> maybeGetInt() &gt;&gt;= mightFail;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Unlike Haskell, <code>operator&gt;&gt;=</code> is <em>right</em> associative in C++, resulting in some convolution when chaining several together. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5b7affb4bcd880f03be8e06b2df3dbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = Requires&lt;Monad&lt;M_&gt;()&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(monad&lt;M_&gt;::bind(std::forward&lt;M&gt;(m), std::forward&lt;F&gt;(f))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience operator for <a class="el" href="structftl_1_1monad.html#a0272e9f5bedd828febd1293c50155442" title="Bind a value and execute a computation in M on it. ">monad::bind</a>. </p>
<p>Mirror of <code>ftl::operator&gt;&gt;=</code>. The only difference is the order of the arguments.</p>
<p>Unlike <code>operator&gt;&gt;=</code>, the fixity of this operator is in fact just as expected, causing it to sometimes be significantly more convenient.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Clean chaining: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m = <a class="code" href="group__maybe.html#gaa5204d8f561ca3ad7024987ed4b82475" title="Convenience function to create maybe:s. ">ftl::value</a>(2.f);</div>
<div class="line"><span class="keyword">auto</span> f = [](<span class="keywordtype">float</span> x){ <span class="keywordflow">return</span> x == 0 ? <a class="code" href="group__maybe.html#ga823f7f4c282db0d2f9bd11326b41baea" title="Convenience instance value of nothing_t. ">nothing</a> : <a class="code" href="group__maybe.html#gaa5204d8f561ca3ad7024987ed4b82475" title="Convenience function to create maybe:s. ">value</a>(8.f/x); };</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> r = f &lt;&lt;= f &lt;&lt;= m;</div>
<div class="line"><span class="comment">// r == value(2.f), or 8 / (8 / 2)</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa69e01a4b56024be56f7be175e0cd5ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt , typename Mu , typename Mt_  = plain_type&lt;Mt&gt;, typename T  = Value_type&lt;Mt_&gt;, typename  = Requires&lt;Monad&lt;Mt_&gt;()&gt;, typename  = Requires&lt;				std::is_same&lt;Rebind&lt;Mu,T&gt;, Mt_&gt;::value			&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mu ftl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Mt &amp;&amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mu &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform two monadic computations, discard result of first. </p>
<p>Using this operator to chain monadic computations is often times more desirable than running them in separate statements, because whatever operations <code>M</code> hides in its bind operation are still performed this way. For example, <code>ftl::nothing</code> propagates down the sequence in the case of <code><a class="el" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe</a></code> and so on.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Basic usage: </p>
<div class="fragment"><div class="line">MyMonad&lt;SomeType&gt; foo();</div>
<div class="line">MyMonad&lt;OtherType&gt; bar();</div>
<div class="line"></div>
<div class="line">MyMonad&lt;OtherType&gt; example() {</div>
<div class="line">    <span class="keyword">using</span> ftl::operator&gt;&gt;;</div>
<div class="line">    <span class="keywordflow">return</span> foo() &gt;&gt; bar();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Equivalent code using plain bind:</span></div>
<div class="line">    <span class="comment">// return foo() &gt;&gt;= [](SomeType){ return bar(); };</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Side effects of bind are preserved: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> e1 = ftl::make_left&lt;int&gt;(string(<span class="stringliteral">&quot;abc&quot;</span>));</div>
<div class="line"><span class="keyword">auto</span> e2 = ftl::make_right&lt;string&gt;(10);</div>
<div class="line"><span class="keyword">auto</span> e3 = ftl::make_right&lt;string&gt;(string(<span class="stringliteral">&quot;123&quot;</span>));</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> r1 = e1 &gt;&gt; e2; <span class="comment">// r1 == make_left&lt;int&gt;(&quot;abc&quot;)</span></div>
<div class="line"><span class="keyword">auto</span> r2 = e2 &gt;&gt; e3; <span class="comment">// r2 == make_right&lt;string&gt;(&quot;123&quot;)</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga4d8f608949a64546f8006329ea242451"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt , typename Mu , typename  = Requires&lt;Monad&lt;Mt&gt;()&gt;, typename T  = Value_type&lt;Mt&gt;, typename U  = Value_type&lt;Mu&gt;, typename  = Requires&lt;				std::is_same&lt;Rebind&lt;Mu,T&gt;, Mt&gt;::value			&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mt ftl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Mt &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mu&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequence two monadic computations, return the first. </p>
<p>Unlike what might be exptected, this operator is used to perform the computations <code>m1</code> and <code>m2</code> in <em>left-to-right</em> order, and then return the result of <code>m1</code>.</p>
<p>Use case is when we have two computations that must be done in sequence, but it's only the first one that yields an interesting result. Most likely, the second one is only needed for a side effect of some kind. In some sense, this is a workaround to the lack of do-notation.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> m1 = <a class="code" href="group__maybe.html#gaa5204d8f561ca3ad7024987ed4b82475" title="Convenience function to create maybe:s. ">ftl::value</a>(8);</div>
<div class="line"><span class="keyword">auto</span> m2 = <a class="code" href="group__maybe.html#gaa5204d8f561ca3ad7024987ed4b82475" title="Convenience function to create maybe:s. ">ftl::value</a>(4);</div>
<div class="line"><a class="code" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe&lt;int&gt;</a> m3;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> r1 = m1 &lt;&lt; m2 <span class="comment">// r1 == value(8)</span></div>
<div class="line"><span class="keyword">auto</span> r2 = m1 &lt;&lt; m3 <span class="comment">// r2 == nothing</span></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga7f4d96431ece1459b333109ad576de1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ftl::ImplementationDefined
	 ftl::mbind</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curried function object representing <code><a class="el" href="structftl_1_1monad.html#a0272e9f5bedd828febd1293c50155442" title="Bind a value and execute a computation in M on it. ">monad::bind</a></code>. </p>
<p>Has a calling type equivalent to </p>
<div class="fragment"><div class="line">(M&lt;T&gt;, (T) -&gt; M&lt;U&gt;) -&gt; M&lt;U&gt;</div>
</div><!-- fragment --><p> where <code>M</code> is an instance of <a class="el" href="monadpg.html">Monad</a>.</p>
<p>Makes for much more convenient calling and passing to higher-order functions.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Trivial usage to sequence two maybes: </p>
<div class="fragment"><div class="line"><a class="code" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe&lt;int&gt;</a> foo(<span class="keywordtype">string</span> s);</div>
<div class="line"></div>
<div class="line"><a class="code" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe&lt;int&gt;</a> exampe(<a class="code" href="classftl_1_1maybe.html" title="Abstracts the concept of optional arguments and similar. ">ftl::maybe&lt;string&gt;</a> ms) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__monad.html#ga7f4d96431ece1459b333109ad576de1e" title="Curried function object representing monad::bind. ">ftl::mbind</a>(ms, foo);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7c0a7f9bec7789fa8d6d4c8743e7ba90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ftl::ImplementationDefined
	 ftl::mjoin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function object representing <code><a class="el" href="structftl_1_1monad.html#ace9c4114296be67f76f887799a3ffed1" title="Joins (or &quot;flattens&quot;) a nested instance of M. ">monad::join</a></code>. </p>
<p>Functions as if it were a function of type </p>
<div class="fragment"><div class="line">(M&lt;M&lt;T&gt;&gt;) -&gt; M&lt;T&gt;</div>
</div><!-- fragment --><p>Proves concise calling syntax for the monadic join operation, allowing cleaner code both for regular use and for passing to higher-order functions.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Straight forward use to flatten a list of lists. No elements are discarded, they will appear in the resulting list in the same order as if a depth-first traversal was made of the original list. </p>
<div class="fragment"><div class="line">std::list&lt;int&gt; flatten(<span class="keyword">const</span> list&lt;list&lt;int&gt;&gt;&amp; l) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__monad.html#ga7c0a7f9bec7789fa8d6d4c8743e7ba90" title="Function object representing monad::join. ">ftl::mjoin</a>(l);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 7 2013 17:07:05 for FTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>FTL: Monad</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FTL
   </div>
   <div id="projectbrief">The Functional Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Monad</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="monadpg.html">Monad</a> concept and related functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__join.html">ftl::deriving_join&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable implementation of <code>monad&lt;M&gt;::join</code>.  <a href="structftl_1_1deriving__join.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__map.html">ftl::deriving_map&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable implementation of <code>monad&lt;M&gt;::map</code>.  <a href="structftl_1_1deriving__map.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__bind.html">ftl::deriving_bind&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable implementation of <code><a class="el" href="structftl_1_1monad.html#aeaeca77ea0895c2a9fc72f33f5156347" title="Bind a value and execute a computation in M on it.">monad::bind</a></code>.  <a href="structftl_1_1deriving__bind.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1deriving__apply.html">ftl::deriving_apply&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inheritable implementation of <code><a class="el" href="structftl_1_1monad.html#a55d9dc66d3ca1a73fa8dd42d427b7e15" title="Applies an encapsulated function to an encapsulated value.">monad::apply</a></code>.  <a href="structftl_1_1deriving__apply.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1mBind.html">ftl::mBind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function object.  <a href="structftl_1_1mBind.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html">ftl::monad&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete definition of the monad concept.  <a href="structftl_1_1monad.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga635fb0423f67f8ee065fedc9fb7763e4"><td class="memTemplParams" colspan="2">template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = typename std::enable_if&lt;monad&lt;M_&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:ga635fb0423f67f8ee065fedc9fb7763e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga635fb0423f67f8ee065fedc9fb7763e4">ftl::operator&gt;&gt;=</a> (M &amp;&amp;m, F &amp;&amp;f) -&gt; decltype(monad&lt; M_ &gt;::bind(std::forward&lt; M &gt;(m), std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:ga635fb0423f67f8ee065fedc9fb7763e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience operator for <a class="el" href="structftl_1_1monad.html#aeaeca77ea0895c2a9fc72f33f5156347" title="Bind a value and execute a computation in M on it.">monad::bind</a>.  <a href="#ga635fb0423f67f8ee065fedc9fb7763e4">More...</a><br/></td></tr>
<tr class="separator:ga635fb0423f67f8ee065fedc9fb7763e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b7affb4bcd880f03be8e06b2df3dbb"><td class="memTemplParams" colspan="2">template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = typename std::enable_if&lt;monad&lt;M_&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:gaa5b7affb4bcd880f03be8e06b2df3dbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaa5b7affb4bcd880f03be8e06b2df3dbb">ftl::operator&lt;&lt;=</a> (F &amp;&amp;f, M &amp;&amp;m) -&gt; decltype(monad&lt; M_ &gt;::bind(std::forward&lt; M &gt;(m), std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:gaa5b7affb4bcd880f03be8e06b2df3dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience operator for <a class="el" href="structftl_1_1monad.html#aeaeca77ea0895c2a9fc72f33f5156347" title="Bind a value and execute a computation in M on it.">monad::bind</a>.  <a href="#gaa5b7affb4bcd880f03be8e06b2df3dbb">More...</a><br/></td></tr>
<tr class="separator:gaa5b7affb4bcd880f03be8e06b2df3dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa69e01a4b56024be56f7be175e0cd5ed"><td class="memTemplParams" colspan="2">template&lt;typename Mt , typename Mu , typename Mt_  = plain_type&lt;Mt&gt;, typename T  = concept_parameter&lt;Mt_&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt_&gt;::instance&gt;::type, typename  = typename std::enable_if&lt;				std::is_same&lt;typename re_parametrise&lt;Mu,T&gt;::type, Mt_&gt;::value			&gt;::type&gt; </td></tr>
<tr class="memitem:gaa69e01a4b56024be56f7be175e0cd5ed"><td class="memTemplItemLeft" align="right" valign="top">Mu&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaa69e01a4b56024be56f7be175e0cd5ed">ftl::operator&gt;&gt;</a> (Mt &amp;&amp;m1, const Mu &amp;m2)</td></tr>
<tr class="memdesc:gaa69e01a4b56024be56f7be175e0cd5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform two monadic computations, discard result of first.  <a href="#gaa69e01a4b56024be56f7be175e0cd5ed">More...</a><br/></td></tr>
<tr class="separator:gaa69e01a4b56024be56f7be175e0cd5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8f608949a64546f8006329ea242451"><td class="memTemplParams" colspan="2">template&lt;typename Mt , typename Mu , typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename T  = concept_parameter&lt;Mt&gt;, typename U  = concept_parameter&lt;Mu&gt;, typename  = typename std::enable_if&lt;				std::is_same&lt;typename re_parametrise&lt;Mu,T&gt;::type, Mt&gt;::value			&gt;::type&gt; </td></tr>
<tr class="memitem:ga4d8f608949a64546f8006329ea242451"><td class="memTemplItemLeft" align="right" valign="top">Mt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga4d8f608949a64546f8006329ea242451">ftl::operator&lt;&lt;</a> (const Mt &amp;m1, Mu m2)</td></tr>
<tr class="memdesc:ga4d8f608949a64546f8006329ea242451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence two monadic computations, return the first.  <a href="#ga4d8f608949a64546f8006329ea242451">More...</a><br/></td></tr>
<tr class="separator:ga4d8f608949a64546f8006329ea242451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga764862b1a3d6622bd8d98cd17e2417f8"><td class="memTemplParams" colspan="2">template&lt;typename Mt , typename F , typename T  = concept_parameter&lt;Mt&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename U  = result_of&lt;F(T)&gt;, typename Mu  = typename re_parametrise&lt;Mt,U&gt;::type&gt; </td></tr>
<tr class="memitem:ga764862b1a3d6622bd8d98cd17e2417f8"><td class="memTemplItemLeft" align="right" valign="top">Mu&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga764862b1a3d6622bd8d98cd17e2417f8">ftl::liftM</a> (F f, const Mt &amp;m)</td></tr>
<tr class="memdesc:ga764862b1a3d6622bd8d98cd17e2417f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifts a function into M.  <a href="#ga764862b1a3d6622bd8d98cd17e2417f8">More...</a><br/></td></tr>
<tr class="separator:ga764862b1a3d6622bd8d98cd17e2417f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf51d1d800fb103d84d9ff601ce8bd299"><td class="memItemLeft" align="right" valign="top">constexpr mBind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#gaf51d1d800fb103d84d9ff601ce8bd299">ftl::mbind</a> {}</td></tr>
<tr class="memdesc:gaf51d1d800fb103d84d9ff601ce8bd299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time instance of <a class="el" href="structftl_1_1mBind.html" title="Convenience function object.">mBind</a>.  <a href="#gaf51d1d800fb103d84d9ff601ce8bd299">More...</a><br/></td></tr>
<tr class="separator:gaf51d1d800fb103d84d9ff601ce8bd299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="monadpg.html">Monad</a> concept and related functions. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ftl/monad.h&gt;</span></div>
</div><!-- fragment --><dl class="section user"><dt>Dependencies</dt><dd><ul>
<li><a class="el" href="group__applicative.html">Applicative Functor</a> </li>
</ul>
</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga635fb0423f67f8ee065fedc9fb7763e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = typename std::enable_if&lt;monad&lt;M_&gt;::instance&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(monad&lt;M_&gt;::bind(std::forward&lt;M&gt;(m), std::forward&lt;F&gt;(f))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience operator for <a class="el" href="structftl_1_1monad.html#aeaeca77ea0895c2a9fc72f33f5156347" title="Bind a value and execute a computation in M on it.">monad::bind</a>. </p>
<p>Basically makes monadic code a lot cleaner. </p>

</div>
</div>
<a class="anchor" id="gaa5b7affb4bcd880f03be8e06b2df3dbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = typename std::enable_if&lt;monad&lt;M_&gt;::instance&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(monad&lt;M_&gt;::bind(std::forward&lt;M&gt;(m), std::forward&lt;F&gt;(f))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience operator for <a class="el" href="structftl_1_1monad.html#aeaeca77ea0895c2a9fc72f33f5156347" title="Bind a value and execute a computation in M on it.">monad::bind</a>. </p>
<p>Mirror of operator &gt;&gt;= </p>

</div>
</div>
<a class="anchor" id="gaa69e01a4b56024be56f7be175e0cd5ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt , typename Mu , typename Mt_  = plain_type&lt;Mt&gt;, typename T  = concept_parameter&lt;Mt_&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt_&gt;::instance&gt;::type, typename  = typename std::enable_if&lt;				std::is_same&lt;typename re_parametrise&lt;Mu,T&gt;::type, Mt_&gt;::value			&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mu ftl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">Mt &amp;&amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mu &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform two monadic computations, discard result of first. </p>
<p>Using this operator to chain monadic computations is often times more desirable than running them in separate statements, because whatever operations <code>M</code> hides in its bind operation are still performed this way (in other words, nothing:s propagate down the chain etc). </p>

</div>
</div>
<a class="anchor" id="ga4d8f608949a64546f8006329ea242451"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt , typename Mu , typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename T  = concept_parameter&lt;Mt&gt;, typename U  = concept_parameter&lt;Mu&gt;, typename  = typename std::enable_if&lt;				std::is_same&lt;typename re_parametrise&lt;Mu,T&gt;::type, Mt&gt;::value			&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mt ftl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const Mt &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mu&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequence two monadic computations, return the first. </p>
<p>This operator is used to perform the computations <code>m1</code> and <code>m2</code> in left-to-right order, and then return the result of <code>m1</code>.</p>
<p>Use case is when we have two computations that must be done in sequence, but it's only the first one that yields an interesting result. Most likely, the second one is only needed for a side effect of some kind. </p>

</div>
</div>
<a class="anchor" id="ga764862b1a3d6622bd8d98cd17e2417f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt , typename F , typename T  = concept_parameter&lt;Mt&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename U  = result_of&lt;F(T)&gt;, typename Mu  = typename re_parametrise&lt;Mt,U&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mu ftl::liftM </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mt &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lifts a function into M. </p>
<p>The function f is lifted into the monadic computation M. Or in other words, the value M is unwrapped, passed to f, and its result rewrapped. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gaf51d1d800fb103d84d9ff601ce8bd299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mBind ftl::mbind {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compile time instance of <a class="el" href="structftl_1_1mBind.html" title="Convenience function object.">mBind</a>. </p>
<p>Makes higher order passing of <a class="el" href="structftl_1_1monad.html#aeaeca77ea0895c2a9fc72f33f5156347" title="Bind a value and execute a computation in M on it.">monad&lt;T&gt;::bind</a> even more convenient. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 27 2013 19:49:02 for FTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>FTL: Monad</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FTL
   </div>
   <div id="projectbrief">The Functional Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Monad</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="monadpg.html">Monad</a> concept and related functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html">ftl::monad&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete definition of the monad concept.  <a href="structftl_1_1monad.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae667046c98546e79b11c780174a0e048"><td class="memTemplParams" colspan="2">template&lt;typename M , typename F , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:gae667046c98546e79b11c780174a0e048"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gae667046c98546e79b11c780174a0e048">ftl::operator&gt;&gt;=</a> (const M &amp;m, F &amp;&amp;f) -&gt; decltype(monad&lt; M &gt;::bind(m, std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:gae667046c98546e79b11c780174a0e048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience operator for <a class="el" href="structftl_1_1monad.html#a163bcc66e4bd7c947bf37a3f83310078" title="Bind a value and execute a computation in M on it.">monad::bind</a>.  <a href="#gae667046c98546e79b11c780174a0e048">More...</a><br/></td></tr>
<tr class="separator:gae667046c98546e79b11c780174a0e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ebacf434ea5b5986c76a1f9418b7bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga36ebacf434ea5b5986c76a1f9418b7bb"></a>
template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = typename std::enable_if&lt;monad&lt;M_&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:ga36ebacf434ea5b5986c76a1f9418b7bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga36ebacf434ea5b5986c76a1f9418b7bb">ftl::operator&gt;&gt;=</a> (M &amp;&amp;m, F &amp;&amp;f) -&gt; decltype(monad&lt; M_ &gt;::bind(std::move(m), std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:ga36ebacf434ea5b5986c76a1f9418b7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga36ebacf434ea5b5986c76a1f9418b7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9856f87a004a485f1b99beb250c35f6"><td class="memTemplParams" colspan="2">template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:gad9856f87a004a485f1b99beb250c35f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gad9856f87a004a485f1b99beb250c35f6">ftl::operator&lt;&lt;=</a> (F &amp;&amp;f, M &amp;&amp;m) -&gt; decltype(monad&lt; M_ &gt;::bind(std::forward&lt; M_ &gt;(m), std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:gad9856f87a004a485f1b99beb250c35f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience operator for <a class="el" href="structftl_1_1monad.html#a163bcc66e4bd7c947bf37a3f83310078" title="Bind a value and execute a computation in M on it.">monad::bind</a>.  <a href="#gad9856f87a004a485f1b99beb250c35f6">More...</a><br/></td></tr>
<tr class="separator:gad9856f87a004a485f1b99beb250c35f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc8cdeb407f99ac95585600c77b3d1b"><td class="memTemplParams" colspan="2">template&lt;typename Mt , typename Mu , typename T  = concept_parameter&lt;Mt&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename  = typename std::enable_if&lt;				std::is_same&lt;typename re_parametrise&lt;Mu,T&gt;::type, Mt&gt;::value			&gt;::type&gt; </td></tr>
<tr class="memitem:ga1dc8cdeb407f99ac95585600c77b3d1b"><td class="memTemplItemLeft" align="right" valign="top">Mu&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga1dc8cdeb407f99ac95585600c77b3d1b">ftl::operator&gt;&gt;</a> (const Mt &amp;m1, const Mu &amp;m2)</td></tr>
<tr class="memdesc:ga1dc8cdeb407f99ac95585600c77b3d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform two monadic computations, discard result of first.  <a href="#ga1dc8cdeb407f99ac95585600c77b3d1b">More...</a><br/></td></tr>
<tr class="separator:ga1dc8cdeb407f99ac95585600c77b3d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94d8bce32649e6cae74b153e9fa5b34c"><td class="memTemplParams" colspan="2">template&lt;typename Mt_ , typename Mu , typename Mt  = plain_type&lt;Mt_&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename T  = concept_parameter&lt;Mt&gt;, typename U  = concept_parameter&lt;Mu&gt;, typename  = typename std::enable_if&lt;				std::is_same&lt;typename re_parametrise&lt;Mu,T&gt;::type, Mt&gt;::value			&gt;::type&gt; </td></tr>
<tr class="memitem:ga94d8bce32649e6cae74b153e9fa5b34c"><td class="memTemplItemLeft" align="right" valign="top">Mt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga94d8bce32649e6cae74b153e9fa5b34c">ftl::operator&lt;&lt;</a> (Mt_ &amp;&amp;m1, Mu m2)</td></tr>
<tr class="memdesc:ga94d8bce32649e6cae74b153e9fa5b34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence two monadic computations, return the first.  <a href="#ga94d8bce32649e6cae74b153e9fa5b34c">More...</a><br/></td></tr>
<tr class="separator:ga94d8bce32649e6cae74b153e9fa5b34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599111a0106c7c9a00d71dcbeababacd"><td class="memTemplParams" colspan="2">template&lt;typename Mt_ , typename F , typename Mt  = plain_type&lt;Mt_&gt;, typename T  = concept_parameter&lt;Mt&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename U  = typename decayed_result&lt;F(T)&gt;::type, typename Mu  = typename re_parametrise&lt;Mt,U&gt;::type&gt; </td></tr>
<tr class="memitem:ga599111a0106c7c9a00d71dcbeababacd"><td class="memTemplItemLeft" align="right" valign="top">Mu&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga599111a0106c7c9a00d71dcbeababacd">ftl::liftM</a> (F f, Mt_ &amp;&amp;m)</td></tr>
<tr class="memdesc:ga599111a0106c7c9a00d71dcbeababacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifts a function into M.  <a href="#ga599111a0106c7c9a00d71dcbeababacd">More...</a><br/></td></tr>
<tr class="separator:ga599111a0106c7c9a00d71dcbeababacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83379adbd329f997d47f12a687256573"><td class="memTemplParams" colspan="2">template&lt;typename Mt , typename Mf , typename T  = concept_parameter&lt;Mt&gt;, typename F  = concept_parameter&lt;Mf&gt;, typename U  = typename decayed_result&lt;F(T)&gt;::type, typename Mu  = typename re_parametrise&lt;Mt,U&gt;::type&gt; </td></tr>
<tr class="memitem:ga83379adbd329f997d47f12a687256573"><td class="memTemplItemLeft" align="right" valign="top">Mu&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga83379adbd329f997d47f12a687256573">ftl::ap</a> (const Mf &amp;f, Mt m)</td></tr>
<tr class="memdesc:ga83379adbd329f997d47f12a687256573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function in M to a value in M.  <a href="#ga83379adbd329f997d47f12a687256573">More...</a><br/></td></tr>
<tr class="separator:ga83379adbd329f997d47f12a687256573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="monadpg.html">Monad</a> concept and related functions. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ftl/monad.h&gt;</span></div>
</div><!-- fragment --><dl class="section user"><dt>Dependencies</dt><dd><ul>
<li><a class="el" href="group__applicative.html">Applicative Functor</a> </li>
</ul>
</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae667046c98546e79b11c780174a0e048"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename F , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(monad&lt;M&gt;::bind(m, std::forward&lt;F&gt;(f))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience operator for <a class="el" href="structftl_1_1monad.html#a163bcc66e4bd7c947bf37a3f83310078" title="Bind a value and execute a computation in M on it.">monad::bind</a>. </p>
<p>Basically makes monadic code a lot cleaner. </p>

</div>
</div>
<a class="anchor" id="gad9856f87a004a485f1b99beb250c35f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename F , typename M_  = plain_type&lt;M&gt;, typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(monad&lt;M_&gt;::bind(std::forward&lt;M_&gt;(m), std::forward&lt;F&gt;(f))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience operator for <a class="el" href="structftl_1_1monad.html#a163bcc66e4bd7c947bf37a3f83310078" title="Bind a value and execute a computation in M on it.">monad::bind</a>. </p>
<p>Mirror of operator &gt;&gt;= </p>

</div>
</div>
<a class="anchor" id="ga1dc8cdeb407f99ac95585600c77b3d1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt , typename Mu , typename T  = concept_parameter&lt;Mt&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename  = typename std::enable_if&lt;				std::is_same&lt;typename re_parametrise&lt;Mu,T&gt;::type, Mt&gt;::value			&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mu ftl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const Mt &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mu &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform two monadic computations, discard result of first. </p>
<p>Using this operator to chain monadic computations is often times more desirable than running them in separate statements, because whatever operations <code>M</code> hides in its bind operation are still performed this way (in other words, nothing:s propagate down the chain etc). </p>

</div>
</div>
<a class="anchor" id="ga94d8bce32649e6cae74b153e9fa5b34c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt_ , typename Mu , typename Mt  = plain_type&lt;Mt_&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename T  = concept_parameter&lt;Mt&gt;, typename U  = concept_parameter&lt;Mu&gt;, typename  = typename std::enable_if&lt;				std::is_same&lt;typename re_parametrise&lt;Mu,T&gt;::type, Mt&gt;::value			&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mt ftl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Mt_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mu&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequence two monadic computations, return the first. </p>
<p>This operator is used to perform the computations <code>m1</code> and <code>m2</code> in left-to-right order, and then return the result of <code>m1</code>.</p>
<p>Use case is when we have two computations that must be done in sequence, but it's only the first one that yields an interesting result. Most likely, the second one is only needed for a side effect of some kind. </p>

</div>
</div>
<a class="anchor" id="ga599111a0106c7c9a00d71dcbeababacd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt_ , typename F , typename Mt  = plain_type&lt;Mt_&gt;, typename T  = concept_parameter&lt;Mt&gt;, typename  = typename std::enable_if&lt;monad&lt;Mt&gt;::instance&gt;::type, typename U  = typename decayed_result&lt;F(T)&gt;::type, typename Mu  = typename re_parametrise&lt;Mt,U&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mu ftl::liftM </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mt_ &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lifts a function into M. </p>
<p>The function f is lifted into the monadic computation M. Or in other words, the value M is unwrapped, passed to f, and its result rewrapped. </p>

</div>
</div>
<a class="anchor" id="ga83379adbd329f997d47f12a687256573"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mt , typename Mf , typename T  = concept_parameter&lt;Mt&gt;, typename F  = concept_parameter&lt;Mf&gt;, typename U  = typename decayed_result&lt;F(T)&gt;::type, typename Mu  = typename re_parametrise&lt;Mt,U&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mu ftl::ap </td>
          <td>(</td>
          <td class="paramtype">const Mf &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mt&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function in M to a value in M. </p>
<p>This is actually exactly equivalent to <a class="el" href="structftl_1_1applicative.html#ac360c626517fd6eb3bdb817834864114" title="Contextualised function application.">applicative&lt;M&gt;::apply</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 26 2013 00:21:12 for FTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>FTL: Monad</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FTL
   </div>
   <div id="projectbrief">The Functional Template Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Monad</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstraction of sequenceable computations in some context.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structftl_1_1monad.html">ftl::monad&lt; M &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete definition of the monad concept.  <a href="structftl_1_1monad.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac3d90b9b20f4255f02d4dddae44db6a3"><td class="memTemplParams" colspan="2">template&lt;typename F , template&lt; typename...&gt; class M, typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:gac3d90b9b20f4255f02d4dddae44db6a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gac3d90b9b20f4255f02d4dddae44db6a3">ftl::operator&gt;&gt;=</a> (const M&lt; A, Ts...&gt; &amp;m, F &amp;&amp;f) -&gt; decltype(monad&lt; M &gt;::bind(m, std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:gac3d90b9b20f4255f02d4dddae44db6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience operator for <a class="el" href="structftl_1_1monad.html#a2eec9ab7658da121ccca6f2c6576695a" title="Bind a value and execute a computation in M on it.">monad::bind</a>.  <a href="#gac3d90b9b20f4255f02d4dddae44db6a3">More...</a><br/></td></tr>
<tr class="separator:gac3d90b9b20f4255f02d4dddae44db6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga654bc887d2b03fd0bf87f25bf39088b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga654bc887d2b03fd0bf87f25bf39088b2"></a>
template&lt;typename F , template&lt; typename &gt; class M, typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:ga654bc887d2b03fd0bf87f25bf39088b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga654bc887d2b03fd0bf87f25bf39088b2">ftl::operator&gt;&gt;=</a> (const M&lt; A &gt; &amp;m, F &amp;&amp;f) -&gt; decltype(monad&lt; M &gt;::bind(m, std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:ga654bc887d2b03fd0bf87f25bf39088b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga654bc887d2b03fd0bf87f25bf39088b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac30e5125063e957c0ca5e94f2a3fd9be"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac30e5125063e957c0ca5e94f2a3fd9be"></a>
template&lt;typename F , template&lt; typename...&gt; class M, typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:gac30e5125063e957c0ca5e94f2a3fd9be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gac30e5125063e957c0ca5e94f2a3fd9be">ftl::operator&gt;&gt;=</a> (M&lt; A, Ts...&gt; &amp;&amp;m, F &amp;&amp;f) -&gt; decltype(monad&lt; M &gt;::bind(std::move(m), std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:gac30e5125063e957c0ca5e94f2a3fd9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gac30e5125063e957c0ca5e94f2a3fd9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab769810913a21013589b212a6f13b96f"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab769810913a21013589b212a6f13b96f"></a>
template&lt;typename F , template&lt; typename &gt; class M, typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:gab769810913a21013589b212a6f13b96f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gab769810913a21013589b212a6f13b96f">ftl::operator&gt;&gt;=</a> (M&lt; A &gt; &amp;&amp;m, F &amp;&amp;f) -&gt; decltype(monad&lt; M &gt;::bind(std::move(m), std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:gab769810913a21013589b212a6f13b96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gab769810913a21013589b212a6f13b96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566a786e59b6a2a39ea6e827ae235ad8"><td class="memTemplParams" colspan="2">template&lt;typename F , template&lt; typename...&gt; class M, typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename B  = typename decayed_result&lt;F(A)&gt;::type::value_type, typename... Ts&gt; </td></tr>
<tr class="memitem:ga566a786e59b6a2a39ea6e827ae235ad8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga566a786e59b6a2a39ea6e827ae235ad8">ftl::operator&lt;&lt;=</a> (F &amp;&amp;f, const M&lt; A, Ts...&gt; &amp;m) -&gt; decltype(monad&lt; M &gt;::bind(m, std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:ga566a786e59b6a2a39ea6e827ae235ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience operator for <a class="el" href="structftl_1_1monad.html#a2eec9ab7658da121ccca6f2c6576695a" title="Bind a value and execute a computation in M on it.">monad::bind</a>.  <a href="#ga566a786e59b6a2a39ea6e827ae235ad8">More...</a><br/></td></tr>
<tr class="separator:ga566a786e59b6a2a39ea6e827ae235ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c48e54cadc0ba599f454f1d9d2c3199"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7c48e54cadc0ba599f454f1d9d2c3199"></a>
template&lt;typename F , template&lt; typename &gt; class M, typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename B  = typename decayed_result&lt;F(A)&gt;::type::value_type&gt; </td></tr>
<tr class="memitem:ga7c48e54cadc0ba599f454f1d9d2c3199"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga7c48e54cadc0ba599f454f1d9d2c3199">ftl::operator&lt;&lt;=</a> (F &amp;&amp;f, const M&lt; A &gt; &amp;m) -&gt; decltype(monad&lt; M &gt;::bind(m, std::forward&lt; F &gt;(f)))</td></tr>
<tr class="memdesc:ga7c48e54cadc0ba599f454f1d9d2c3199"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga7c48e54cadc0ba599f454f1d9d2c3199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef9c3800cc8f483097156394cfebb4be"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:gaef9c3800cc8f483097156394cfebb4be"><td class="memTemplItemLeft" align="right" valign="top">M&lt; B, Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaef9c3800cc8f483097156394cfebb4be">ftl::operator&gt;&gt;</a> (const M&lt; A, Ts...&gt; &amp;m1, M&lt; B, Ts...&gt; m2)</td></tr>
<tr class="memdesc:gaef9c3800cc8f483097156394cfebb4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform two monadic computations, discard result of first.  <a href="#gaef9c3800cc8f483097156394cfebb4be">More...</a><br/></td></tr>
<tr class="separator:gaef9c3800cc8f483097156394cfebb4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e974dfb269c2d142cd1e7ea8fb334bc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0e974dfb269c2d142cd1e7ea8fb334bc"></a>
template&lt;template&lt; typename...&gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:ga0e974dfb269c2d142cd1e7ea8fb334bc"><td class="memTemplItemLeft" align="right" valign="top">M&lt; B, Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga0e974dfb269c2d142cd1e7ea8fb334bc">ftl::operator&gt;&gt;</a> (M&lt; A, Ts...&gt; &amp;&amp;m1, M&lt; B, Ts...&gt; m2)</td></tr>
<tr class="memdesc:ga0e974dfb269c2d142cd1e7ea8fb334bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga0e974dfb269c2d142cd1e7ea8fb334bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e5e029432c7f412a4fa1cd56ea49a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga92e5e029432c7f412a4fa1cd56ea49a2"></a>
template&lt;template&lt; typename &gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:ga92e5e029432c7f412a4fa1cd56ea49a2"><td class="memTemplItemLeft" align="right" valign="top">M&lt; B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga92e5e029432c7f412a4fa1cd56ea49a2">ftl::operator&gt;&gt;</a> (const M&lt; A &gt; &amp;m1, M&lt; B &gt; m2)</td></tr>
<tr class="memdesc:ga92e5e029432c7f412a4fa1cd56ea49a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga92e5e029432c7f412a4fa1cd56ea49a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e011e255863d2016c950fc43c09851d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7e011e255863d2016c950fc43c09851d"></a>
template&lt;template&lt; typename &gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:ga7e011e255863d2016c950fc43c09851d"><td class="memTemplItemLeft" align="right" valign="top">M&lt; B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga7e011e255863d2016c950fc43c09851d">ftl::operator&gt;&gt;</a> (M&lt; A &gt; &amp;&amp;m1, M&lt; B &gt; m2)</td></tr>
<tr class="memdesc:ga7e011e255863d2016c950fc43c09851d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga7e011e255863d2016c950fc43c09851d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3d3917cf08b033d80b011e08b377276"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:gaa3d3917cf08b033d80b011e08b377276"><td class="memTemplItemLeft" align="right" valign="top">M&lt; A, Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaa3d3917cf08b033d80b011e08b377276">ftl::operator&lt;&lt;</a> (const M&lt; A, Ts...&gt; &amp;m1, M&lt; B, Ts...&gt; m2)</td></tr>
<tr class="memdesc:gaa3d3917cf08b033d80b011e08b377276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence two monadic computations, return the first.  <a href="#gaa3d3917cf08b033d80b011e08b377276">More...</a><br/></td></tr>
<tr class="separator:gaa3d3917cf08b033d80b011e08b377276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a7fd8687e9e0219928152ae1a0a1e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga74a7fd8687e9e0219928152ae1a0a1e4"></a>
template&lt;template&lt; typename...&gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:ga74a7fd8687e9e0219928152ae1a0a1e4"><td class="memTemplItemLeft" align="right" valign="top">M&lt; A, Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga74a7fd8687e9e0219928152ae1a0a1e4">ftl::operator&lt;&lt;</a> (M&lt; A, Ts...&gt; &amp;&amp;m1, M&lt; B, Ts...&gt; m2)</td></tr>
<tr class="memdesc:ga74a7fd8687e9e0219928152ae1a0a1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga74a7fd8687e9e0219928152ae1a0a1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86b5692ac1266254868f984711aa1ba6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga86b5692ac1266254868f984711aa1ba6"></a>
template&lt;template&lt; typename &gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:ga86b5692ac1266254868f984711aa1ba6"><td class="memTemplItemLeft" align="right" valign="top">M&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga86b5692ac1266254868f984711aa1ba6">ftl::operator&lt;&lt;</a> (const M&lt; A &gt; &amp;m1, M&lt; B &gt; m2)</td></tr>
<tr class="memdesc:ga86b5692ac1266254868f984711aa1ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga86b5692ac1266254868f984711aa1ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa0a820b9a056604b3134e3afc10c02"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaffa0a820b9a056604b3134e3afc10c02"></a>
template&lt;template&lt; typename &gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type&gt; </td></tr>
<tr class="memitem:gaffa0a820b9a056604b3134e3afc10c02"><td class="memTemplItemLeft" align="right" valign="top">M&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaffa0a820b9a056604b3134e3afc10c02">ftl::operator&lt;&lt;</a> (M&lt; A &gt; &amp;&amp;m1, M&lt; B &gt; m2)</td></tr>
<tr class="memdesc:gaffa0a820b9a056604b3134e3afc10c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gaffa0a820b9a056604b3134e3afc10c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca4a23317be98f7481cf9f6ac976a07"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename R  = typename decayed_result&lt;F(A)&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:gaeca4a23317be98f7481cf9f6ac976a07"><td class="memTemplItemLeft" align="right" valign="top">M&lt; R, Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaeca4a23317be98f7481cf9f6ac976a07">ftl::liftM</a> (F f, const M&lt; A, Ts...&gt; &amp;m)</td></tr>
<tr class="memdesc:gaeca4a23317be98f7481cf9f6ac976a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lifts a function into M.  <a href="#gaeca4a23317be98f7481cf9f6ac976a07">More...</a><br/></td></tr>
<tr class="separator:gaeca4a23317be98f7481cf9f6ac976a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb4a0a022cdef0b6d6dcf21ba8b3dd53"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadb4a0a022cdef0b6d6dcf21ba8b3dd53"></a>
template&lt;template&lt; typename...&gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename R  = typename decayed_result&lt;F(A)&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:gadb4a0a022cdef0b6d6dcf21ba8b3dd53"><td class="memTemplItemLeft" align="right" valign="top">M&lt; R, Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gadb4a0a022cdef0b6d6dcf21ba8b3dd53">ftl::liftM</a> (F f, M&lt; A, Ts...&gt; &amp;&amp;m)</td></tr>
<tr class="memdesc:gadb4a0a022cdef0b6d6dcf21ba8b3dd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gadb4a0a022cdef0b6d6dcf21ba8b3dd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga195bffc42e35a66d38dd319b2f238e7c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga195bffc42e35a66d38dd319b2f238e7c"></a>
template&lt;template&lt; typename &gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename R  = typename decayed_result&lt;F(A)&gt;::type&gt; </td></tr>
<tr class="memitem:ga195bffc42e35a66d38dd319b2f238e7c"><td class="memTemplItemLeft" align="right" valign="top">M&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga195bffc42e35a66d38dd319b2f238e7c">ftl::liftM</a> (F f, const M&lt; A &gt; &amp;m)</td></tr>
<tr class="memdesc:ga195bffc42e35a66d38dd319b2f238e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga195bffc42e35a66d38dd319b2f238e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2ab60dce5043a21009e3c1d9123d5f8"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac2ab60dce5043a21009e3c1d9123d5f8"></a>
template&lt;template&lt; typename &gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename R  = typename decayed_result&lt;F(A)&gt;::type&gt; </td></tr>
<tr class="memitem:gac2ab60dce5043a21009e3c1d9123d5f8"><td class="memTemplItemLeft" align="right" valign="top">M&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gac2ab60dce5043a21009e3c1d9123d5f8">ftl::liftM</a> (F f, M&lt; A &gt; &amp;&amp;m)</td></tr>
<tr class="memdesc:gac2ab60dce5043a21009e3c1d9123d5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gac2ab60dce5043a21009e3c1d9123d5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd504439b061e84f443510f5aad58325"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename...&gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename B  = typename decayed_result&lt;F(A)&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:gafd504439b061e84f443510f5aad58325"><td class="memTemplItemLeft" align="right" valign="top">M&lt; B, Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gafd504439b061e84f443510f5aad58325">ftl::ap</a> (const M&lt; F, Ts...&gt; &amp;f, M&lt; A, Ts...&gt; m)</td></tr>
<tr class="memdesc:gafd504439b061e84f443510f5aad58325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function in M to a value in M.  <a href="#gafd504439b061e84f443510f5aad58325">More...</a><br/></td></tr>
<tr class="separator:gafd504439b061e84f443510f5aad58325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54bbd19d9db26c2011860b39871877ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga54bbd19d9db26c2011860b39871877ad"></a>
template&lt;template&lt; typename...&gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename B  = typename decayed_result&lt;F(A)&gt;::type, typename... Ts&gt; </td></tr>
<tr class="memitem:ga54bbd19d9db26c2011860b39871877ad"><td class="memTemplItemLeft" align="right" valign="top">M&lt; B, Ts...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga54bbd19d9db26c2011860b39871877ad">ftl::ap</a> (M&lt; F, Ts...&gt; &amp;&amp;f, M&lt; A, Ts...&gt; m)</td></tr>
<tr class="memdesc:ga54bbd19d9db26c2011860b39871877ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga54bbd19d9db26c2011860b39871877ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1802a6317c02914441bea73711b5fd9"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab1802a6317c02914441bea73711b5fd9"></a>
template&lt;template&lt; typename &gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename B  = typename decayed_result&lt;F(A)&gt;::type&gt; </td></tr>
<tr class="memitem:gab1802a6317c02914441bea73711b5fd9"><td class="memTemplItemLeft" align="right" valign="top">M&lt; B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gab1802a6317c02914441bea73711b5fd9">ftl::ap</a> (const M&lt; F &gt; &amp;f, M&lt; A &gt; m)</td></tr>
<tr class="memdesc:gab1802a6317c02914441bea73711b5fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:gab1802a6317c02914441bea73711b5fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga633f0c46f6a37dc6b30ff12dfc28c971"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga633f0c46f6a37dc6b30ff12dfc28c971"></a>
template&lt;template&lt; typename &gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename B  = typename decayed_result&lt;F(A)&gt;::type&gt; </td></tr>
<tr class="memitem:ga633f0c46f6a37dc6b30ff12dfc28c971"><td class="memTemplItemLeft" align="right" valign="top">M&lt; B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga633f0c46f6a37dc6b30ff12dfc28c971">ftl::ap</a> (M&lt; F &gt; &amp;&amp;f, M&lt; A &gt; m)</td></tr>
<tr class="memdesc:ga633f0c46f6a37dc6b30ff12dfc28c971"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br/></td></tr>
<tr class="separator:ga633f0c46f6a37dc6b30ff12dfc28c971"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Abstraction of sequenceable computations in some context. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ftl/monad.h&gt;</span></div>
</div><!-- fragment --><p>Monads are essentially just a functor with some additional structure. Specifically, types that are monads have the added functionality (on top of what applicative adds) of sequencing computations in the context of the monad.</p>
<p>While this is technically already possible in C++, the abstraction is useful none the less, because monads also have the power to implicitly pass state or other useful context information forward, without the user having to bother with it.</p>
<p>The easiest example of the above is probably the maybe monad, where the user does not need to manually check for nothingness except at the very end of a sequence of computations&mdash;because maybe's implementation of <a class="el" href="structftl_1_1monad.html#a2eec9ab7658da121ccca6f2c6576695a" title="Bind a value and execute a computation in M on it.">monad&lt;M&gt;::bind</a> does that for them.</p>
<p>As with many of the other concepts in FTL, monads have a set of associated laws that instances must follow (though technically, there is nothing enforcing them):</p>
<ul>
<li><b>Left identity law</b> <div class="fragment"><div class="line">pure(x) &gt;&gt;= f    &lt;=&gt; f(x)</div>
</div><!-- fragment --></li>
<li><b>Right identity law</b> <div class="fragment"><div class="line">m &gt;&gt;= pure&lt;T&gt;    &lt;=&gt; m</div>
</div><!-- fragment --></li>
<li><b>Law of associativity</b> <div class="fragment"><div class="line">(m &gt;&gt;= f) &gt;&gt;= g) &lt;=&gt; m &gt;&gt;= ([f](X x){<span class="keywordflow">return</span> f(x);} &gt;&gt;= g)</div>
</div><!-- fragment --></li>
</ul>
<dl class="section user"><dt>Dependencies</dt><dd><ul>
<li><a class="el" href="group__applicative.html">Applicative Functor</a> </li>
</ul>
</dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac3d90b9b20f4255f02d4dddae44db6a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , template&lt; typename...&gt; class M, typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const M&lt; A, Ts...&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(monad&lt;M&gt;::bind(m, std::forward&lt;F&gt;(f))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience operator for <a class="el" href="structftl_1_1monad.html#a2eec9ab7658da121ccca6f2c6576695a" title="Bind a value and execute a computation in M on it.">monad::bind</a>. </p>
<p>Basically makes monadic code a lot cleaner. </p>

</div>
</div>
<a class="anchor" id="ga566a786e59b6a2a39ea6e827ae235ad8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , template&lt; typename...&gt; class M, typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename B  = typename decayed_result&lt;F(A)&gt;::type::value_type, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto ftl::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M&lt; A, Ts...&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(monad&lt;M&gt;::bind(m, std::forward&lt;F&gt;(f))) </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience operator for <a class="el" href="structftl_1_1monad.html#a2eec9ab7658da121ccca6f2c6576695a" title="Bind a value and execute a computation in M on it.">monad::bind</a>. </p>
<p>Mirror of operator &gt;&gt;= </p>

</div>
</div>
<a class="anchor" id="gaef9c3800cc8f483097156394cfebb4be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename...&gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M&lt;B,Ts...&gt; ftl::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const M&lt; A, Ts...&gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&lt; B, Ts...&gt;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform two monadic computations, discard result of first. </p>
<p>Using this operator to chain monadic computations is often times more desirable than running them in separate statements, because whatever operations <code>M</code> hides in its bind operation are still performed this way (in other words, nothing:s propagate down the chain etc). </p>

</div>
</div>
<a class="anchor" id="gaa3d3917cf08b033d80b011e08b377276"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename...&gt; class M, typename A , typename B , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M&lt;A,Ts...&gt; ftl::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const M&lt; A, Ts...&gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&lt; B, Ts...&gt;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequence two monadic computations, return the first. </p>
<p>This operator is used to perform the computations <code>m1</code> and <code>m2</code> in left-to-right order, and then return the result of <code>m1</code>.</p>
<p>Use case is when we have two computations that must be done in sequence, but it's only the first one that yields an interesting result. Most likely, the second one is only needed for a side effect of some kind. </p>

</div>
</div>
<a class="anchor" id="gaeca4a23317be98f7481cf9f6ac976a07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename...&gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename R  = typename decayed_result&lt;F(A)&gt;::type, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M&lt;R,Ts...&gt; ftl::liftM </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M&lt; A, Ts...&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lifts a function into M. </p>
<p>The function f is lifted into the monadic computation M. Or in other words, the value M is unwrapped, passed to f, and its result rewrapped. </p>

</div>
</div>
<a class="anchor" id="gafd504439b061e84f443510f5aad58325"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename...&gt; class M, typename F , typename A , typename  = typename std::enable_if&lt;monad&lt;M&gt;::instance&gt;::type, typename B  = typename decayed_result&lt;F(A)&gt;::type, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M&lt;B,Ts...&gt; ftl::ap </td>
          <td>(</td>
          <td class="paramtype">const M&lt; F, Ts...&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M&lt; A, Ts...&gt;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function in M to a value in M. </p>
<p>This is actually exactly equivalent to <a class="el" href="structftl_1_1applicative.html#a0cd7e6888d5dc84dd84dfafc383b3cc6" title="Contextualised function application.">applicative&lt;M&gt;::apply</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 14 2013 19:01:39 for FTL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>

When starting the development of FTL, I was faced with an immediate problem: how to represent the type classes (in simple terms, Haskell's name for concepts)? Functionally, whatever implementation I chose had the following hard requirements:

* A concept must be open, i.e. it must be possible for types unknown to me to implement a particular concept.
* Functions, methods, and other callables must be at least compile-time polymorphic on concept. Which is to say, a function must be capable of invoking the correct versions of @map@, @apply@, @pure@, and so on for a particular implementation of e.g. __Applicative__, without knowing more about the type than that it _is_ an implementation of that concept.
* It must be possible to make the concept representations type parametric. In other words, it must be possible to express @Functor<A>@, where @A@ is some templated type.
* Complex type signatures such as @Functor<B>(B(A), Functor<A>)@ must be expressible in the representation.
* _Existing_ types must be extensible to take advantage of FTL concepts. I did not want to re-implement the entire standard library, nor deprive people of its use. 

At the time when I did my first experiment, none of these requirements had really manifested in a concrete way in my mind. I was just having some fun. In any case, this first idea involved inheritance (I figured that because Haskell's type classes are run-time polymorphic, mine should be too), and got more or less nowhere. I don't recall the specifics, but the very first thing I wrote up might have looked something like this:

bc..

template<typename T>
class Functor {
	template<typename F, typename U = std::result_of<F(T)>::type>
	virtual Functor<U> map(F&& f) = 0;
};

p. Astute readers may already have noticed the (largest, of several) problem(s): templated methods cannot be virtual. I did some work to get around this, but fairly quickly realised that it was impossible to express what I wanted in this style. The number one reason for this is the function template parameter, @F@. If I wanted to allow the mapping of functions that change domain--and I did--there was always going to be at least one template parameter. 

For my next attempt, I gave up on run-time polymorphism. It got me quite far, but was very ugly and incompatible with clang (because clang does not allow template specialisation on number of template parameters--whether gcc or clang is correct in this, I don't know). It basically looked a bit like this:

bc...

// Multiple parameter type constructors
template<template <typename...> class F>
struct functor {
	template<typename F, typename T, typename U = typename std::result_of<F(T)>::type, typename...Ts>
	static F<U,Ts...> map(Fn&& fn, const F<T,Ts...>& f) {
		// returned a call to applicative<F>::map
	}

	static constexpr bool instance = applicative<F>::instance;
};

// Single parameter type constructors
template<template <typename> class F>
struct functor<F> {
	// decayed_result is a template meta function that is basically just a composition of
	// std::decay and std::result_of. Used to prevent accidentally getting a maybe<const T&>
	// and similar
	template<typename F, typename T, typename U = typename decayed_result<F(T)>::type>
	static F<U> map(Fn&& fn, const F<T>& f);

	static constexpr bool instance = applicative<F>::instance;
};

p. Concept implementations would specialise one of these structs and provide implementations of the static functions. With the addition of the compile time constant, @instance@, in each implementation, functions that accepted e.g. a functor could now specify as much in their signature, hiding itself from non-instances with SFINAE:

bc..

template<
	typename A,
	typename B,
	template <typename> class F,
	typename = typename std::enable_if<functor<F>::instance>::type>
void example(F<A> a, F<B> b);

p.  This version also allowed me to give concept implementations for many of the standard library types, and seemed flexible enough to cover most cases I could think of. It even allowed me to make auotomatic implementations for __Functor__ and __Applicative__ if there existed one for __Monad__. Sure, allocator aware containers were a bit of a nuisance, and I was slighly peeved that my @either@ data type had to be a __Functor__ in its _left_ type--instead of the more logical (and Haskell consistent) right type--but it worked. Somewhere around this point, the project began to be more than just toying around.

In any case, this concept representation lived on for quite a while, including all the clunkiness of having to define functions such as @example@ above _twice_. Once for single parameter type constructors, and once for multi parameter ones. It was always in the back of my mind to fix this issue, as well as the incompatibility with clang, but for some time, I was preoccupied by other challenges.

Eventually, I ran into a hard limit of the system: it was impossible to implement monad transformers. After some struggle, I arrived at what is essentially today's representation:

bc..

template<typename F>
struct functor {
	using T = concept_param<F>;

	template<
		typename Fn,
		typename U = typename std::result_of<Fn(T)>::type,
		typename Fu = typename re_parametrise<F,U>::type
	>
	static Fu map(Fn&& fn, const F& f) {
		return applicative<F>::map(std::forward<Fn>(fn), f);
	}

	static constexpr bool instance = applicative<F>::instance;
	
};

p. The most notable change here is that instead of accepting a template template parameter, the functor "interface" accepts a complete type, and uses some template meta functions I wrote to extract and change the concept parameter. This proved to be much more flexible and even solved the whole issue with duplicating everything for single/multi parameter implementors! There was also an unexpected benefit: I could specialise the @concept_param@ and @re_parametrise@ meta functions for different types, finally allowing @either@ to be a functor in its _right_ type, fixing most of my concerns with allocator aware containers, and so on.

Now we've reached present time in this little journey through time, and that is unfortunately where it ends. I do not yet know how the representation will change in the future, except that it definitely _will_. For one, if the concepts lite proposal goes through, it will at least change _some_ parts of FTL's concepts. At the very least, most of the overly verbose and ugly SFINAE clauses will be changed to simple concept requirement clauses.

Naturally, if/when _full_ concepts as originally envisioned become available, the current representation will be rendered entirely moot; weeks of work and toil will become irrelevant. I welcome that day!



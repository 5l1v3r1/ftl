/*
 * Copyright (c) 2013 Bj√∂rn Aili
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 *
 * 3. This notice may not be removed or altered from any source
 * distribution.
 */
#ifndef FTL_TYPE_TRAITS_H
#define FTL_TYPE_TRAITS_H

#define FTL_GEN_PREFIX_UNOP_TEST(op, name)\
	template<typename T>\
	bool test_ ## name (decltype(op std::declval<T>())*);\
	\
	template<typename T>\
	no test_ ## name (...)

#define FTL_GEN_POSTFIX_UNOP_TEST(op, name)\
	template<typename T>\
	bool test_ ## name (decltype(std::declval<T>() op)*);\
	\
	template<typename T>\
	no test_ ## name (...)

#define FTL_GEN_BINOP_TEST(op, name)\
	template<typename T>\
	bool test_ ## name (decltype(std::declval<T>() op std::declval<T>())*);\
	\
	template<typename T>\
	no test_ ## name (...)

#define FTL_GEN_UNFN_TEST(fn, name)\
	template<typename T>\
	bool test_ ## name (decltype( fn (std::declval<T>()))*);\
	\
	template<typename T>\
	no test_ ## name (...)

#define FTL_GEN_BINFN_TEST(fn, name)\
	template<typename T>\
	bool test_ ## name (decltype( fn (std::declval<T>(), std::declval<T>()))*);\
	\
	template<typename T>\
	no test_ ## name (...)

namespace ftl {
	/**
	 * \defgroup typetraits Type Traits
	 *
	 * Collection of useful type traits.
	 *
	 * The main difference between this module and \ref typelevel is that
	 * this module is concerned with finding out particular properties of types,
	 * \ref typelevel is concerned with _modifying_ types.
	 *
	 * \code
	 *   #include <ftl/type_traits.h>
	 * \endcode
	 *
	 * \par Dependencies
	 * N/A
	 */

	namespace _dtl {
		struct no {};

		FTL_GEN_BINOP_TEST(==, eq);
		FTL_GEN_BINOP_TEST(!=, neq);
		FTL_GEN_BINOP_TEST(<, lt);
		FTL_GEN_BINOP_TEST(<, gt);

		FTL_GEN_PREFIX_UNOP_TEST(++, preinc);
		FTL_GEN_POSTFIX_UNOP_TEST(++, postinc);

		FTL_GEN_UNFN_TEST(std::begin, begin);
		FTL_GEN_UNFN_TEST(std::end, end);
	}

	// The type functions below could have been autogenerated, but this way
	// they're easier to document.

	/**
	 * Type trait to test for `operator==()`
	 *
	 * Example:
	 * \code
	 *   template<typename T>
	 *   auto foo() -> typename std::enable_if<ftl::has_eq<T>::value>::type {
	 *       // ...
	 *       if(some_t == other_t)
	 *       // ...
	 *   }
	 * \endcode
	 *
	 * \ingroup typetraits
	 */
	template<typename T>
	struct has_eq {
		static constexpr bool value = 
			!std::is_same<
				_dtl::no,
				decltype(_dtl::test_eq<T>(nullptr))
			>::value;
	};

	/**
	 * Test a type for `operator!=()`
	 *
	 * Example:
	 * \code
	 *   template<typename T>
	 *   auto foo() -> typename std::enable_if<ftl::has_neq<T>::value>::type {
	 *       // ...
	 *       if(some_t != other_t)
	 *       // ...
	 *   }
	 * \endcode
	 *
	 * \ingroup typetraits
	 */
	template<typename T>
	struct has_neq {
		static constexpr bool value = 
			!std::is_same<
				_dtl::no,
				decltype(_dtl::test_neq<T>(nullptr))
			>::value;
	};


	/**
	 * Test a type for `operator<()`
	 *
	 * Example:
	 * \code
	 *   template<typename T>
	 *   auto foo() -> typename std::enable_if<ftl::has_lt<T>::value>::type {
	 *       // ...
	 *       if(some_t < other_t)
	 *       // ...
	 *   }
	 * \endcode
	 *
	 * \ingroup typetraits
	 */
	template<typename T>
	struct has_lt {
		static constexpr bool value =
			!std::is_same<
				_dtl::no,
				decltype(_dtl::test_lt<T>(nullptr))
			>::value;
	};

	/**
	 * Test a type for `operator>()`
	 *
	 * Example:
	 * \code
	 *   template<typename T>
	 *   auto foo() -> typename std::enable_if<ftl::has_gt<T>::value>::type {
	 *       // ...
	 *       if(some_t > other_t)
	 *       // ...
	 *   }
	 * \endcode
	 *
	 * \ingroup typetraits
	 */
	template<typename T>
	struct has_gt {
		static constexpr bool value =
			!std::is_same<
				_dtl::no,
				decltype(_dtl::test_gt<T>(nullptr))
			>::value;
	};

	/**
	 * Test a type for `operator++()`.
	 *
	 * Example:
	 * \code
	 *   template<typename T>
	 *   auto foo()
	 *   -> typename std::enable_if<ftl::has_pre_inc<T>::value>::type {
	 *       // ...
	 *       ++some_t;
	 *   }
	 * \endcode
	 *
	 * \ingroup typetraits
	 */
	template<typename T>
	struct has_pre_inc {
		static constexpr bool value =
			!std::is_same<
				_dtl::no,
				decltype(_dtl::test_preinc<T>(nullptr))
			>::value;
	};

	/**
	 * Test a type for `operator++(int)`.
	 *
	 * Example:
	 * \code
	 *   template<typename T>
	 *   auto foo()
	 *   -> typename std::enable_if<ftl::has_post_inc<T>::value>::type {
	 *       // ...
	 *       some_t++;
	 *   }
	 * \endcode
	 *
	 * \ingroup typetraits
	 */
	template<typename T>
	struct has_post_inc {
		static constexpr bool value =
			!std::is_same<
				_dtl::no,
				decltype(_dtl::test_postinc<T>(nullptr))
			>::value;
	};

	/**
	 * Test a type for `std::begin()` compatibility.
	 *
	 * Example:
	 * \code
	 *   template<
	 *   	typename T,
	 *   	typename = typename std::enable_if<
	 *   	    ftl::has_begin<T>::value
	 *   	    && ftl::has_end<T>::value
	 *   	>::type
	 *   >
	 *   void foo() {
	 *       for(auto& e : some_t) {
	 *           // ...
	 *       }
	 *   }
	 * \endcode
	 *
	 * \ingroup typetraits
	 */
	template<typename T>
	struct has_begin {
		static constexpr bool value =
			!std::is_same<
				_dtl::no,
				decltype(_dtl::test_begin<T>(nullptr))
			>::value;
	};

	/**
	 * Test a type for `std::end()` compatibility.
	 *
	 * Example:
	 * \code
	 *   template<
	 *   	typename T,
	 *   	typename = typename std::enable_if<
	 *   	    ftl::has_begin<T>::value
	 *   	    && ftl::has_end<T>::value
	 *   	>::type
	 *   >
	 *   void foo() {
	 *       for(auto& e : some_t) {
	 *           // ...
	 *       }
	 *   }
	 * \endcode
	 *
	 * \ingroup typetraits
	 */
	template<typename T>
	struct has_end {
		static constexpr bool value =
			!std::is_same<
				_dtl::no,
				decltype(_dtl::test_end<T>(nullptr))
			>::value;
	};
}

#endif

